øiexportTaggdefaultnoriginalSamplex1
fun main() {
Int::foo
}
val <T> T.foo get() = 1
gmutantsüxi

val e = false
if (e) {fun main() {
Int::foo
}} else {fun main() {
Int::foo
}}

val <T> T.foo get() = 1
xi
fun main() {
Int::foo
}

val n = false
if (n) {val <T> T.foo get() = 1} else {val <T> T.foo get() = 1}

xf
fun main() 
val t = true
try
{{
Int::foo
}}
catch(e: Exception){}
finally{}

val <T> T.foo get() = 1
xf
fun main() {
Int::foo
}
val <T> T.foo 
val t = true
try
{get() = 1}
catch(e: Exception){}
finally{}

xY
fun main() {

val j = true
if (j) {Int::foo} else {Int::foo}

}
val <T> T.foo get() = 1
xS
fun main() {
Int::foo
}
val <
val j = false
if (j) {T} else {T}
> T.foo get() = 1
xR
fun main() {
Int::foo
}
val <T> T.foo get() = 
val n = true
if (n) {1} else {1}

xf
fun main() {

val d = true
try
{Int}
catch(e: Exception){}
finally{}
::foo
}
val <T> T.foo get() = 1
xh
fun main() {
Int::
val k = false
when (k) {
 true -> {foo}
 else -> {foo}
}

}
val <T> T.foo get() = 1
xR
fun main() {
Int::foo
}
val <T> 
val u = true
if (u) {T} else {T}
.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> (T)?.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> T!!.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() {
1
}
val <T> T.foo get() = Int::foo
x1
fun }() {
Int::foo
main
val <T> T.foo get() = 1
x1
T
val <T> fun main() {
Int::foo
}.foo get() = 1
x1
fun main(get {
Int::foo
}
val <T> T.foo )() = 1
x1
fun main() get
val <T> T.foo {
Int::foo
}() = 1
x1
fun main() {
Int::foo
}
val <T> (.foo getT) = 1
x1
foo main() {
Int::foo
}
val <T> T.fun get() = 1
x1
fun main() {
Int::foo
}
val get() = 1T> T.foo <
x1
fun main() {
Int::foo
}
val <T> T.foo get() 1 =
x1
fun mainInt) {
(::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> ).foo get(T = 1
x1
fun 1() {
Int::foo
}
val <T> T.foo get() = main
x1
fun main() val <T> T.foo get() = 1
Int::foo
}
{
x1
fun main() {
Int::foo
=
val <T> T.foo get() } 1
x1
1
val <T> T.foo get() = fun main() {
Int::foo
}
x1
fun main() {
Int::foo
}
val <T> T.foo )(get = 1
x1
fun main() {
(::foo
}
val <T> T.foo getInt) = 1
x1
fun main() {
T
}
val <T> Int::foo.foo get() = 1
x1
fun main(} {
Int::foo
)
val <T> T.foo get() = 1
x1
fun main() {
>
}
val <TInt::foo T.foo get() = 1
x1
fun main() {
<T>::foo
}
val Int T.foo get() = 1
x1
fun main() )
Int::foo
}
val <T> T.foo get({ = 1
x1
fun main() {
Int::get
}
val <T> T.foo foo() = 1
x1
fun main> {
Int::foo
}
val <T() T.foo get() = 1
x1
fun main() {
foo::Int
}
val <T> T.foo get() = 1
x1
fun <() {
Int::foo
}
val mainT> T.foo get() = 1
x1
fun main(get() = 1 {
Int::foo
}
val <T> T.foo )
x1
fun main() val
Int::foo
}
{ <T> T.foo get() = 1
x1
fun main() 1
val <T> T.foo get() = {
Int::foo
}
x1
fun main() {
Int::foo
}
val <T> get() = 1.foo T
x1
fun main() {
Int::foo
}
val TT> <.foo get() = 1
x1
fun main() {
Int::foo
}
val <Tget T.foo >() = 1
x1
fun Int() {
main::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
< valT> T.foo get() = 1
x1
)
val <T> T.foo get(fun main() {
Int::foo
} = 1
x1
fun main() {
Int::foo
}
val T<> T.foo get() = 1
x1
fun main() {
get::foo
}
val <T> T.foo Int() = 1
x1
fun .() {
Int::foo
}
val <T> Tmainfoo get() = 1
x1
fun main() {
Int<T>foo
}
val :: T.foo get() = 1
x1
fun mainval <T> T.foo get() = 1 {
Int::foo
}
()
x1
fun main() =
val <T> T.foo get() {
Int::foo
} 1
x1
fun main() {
Int::foo
}
val T <T>.foo get() = 1
x1
fun main() {
Int::1
}
val <T> T.foo get() = foo
x1
fun main() {
Int::foo
}
val <T> .Tfoo get() = 1
x1
fun main() (
val <T> T.foo get{
Int::foo
}) = 1
x1
fun main() {
Int::foo
}
val <1> T.foo get() = T
x1
1 main() {
Int::foo
}
val <T> T.foo get() = fun
x1
fun main() {
Int::foo
}
val <T> T.1 get() = foo
x1
fun main() {
Int::<T>
}
val foo T.foo get() = 1
x1
fun main() {
Intval <T> T.foo get() = 1foo
}
::
x1
fun main) {
Int::foo
}
val <T> T.foo get(() = 1
x1
fun main() {
Int::foo
val <T> T.foo get() = 1
}
x1
fun main() 1
Int::foo
}
val <T> T.foo get() = {
x1
fun main() {
Int::foo
}
val get T.foo <T>() = 1
x1
fun main() {
Int::foo
}
val <foo> T.T get() = 1
x1
fun main() {
)::foo
}
val <T> T.foo get(Int = 1
x1
fun mainfoo {
Int::foo
}
val <T> T.() get() = 1
x1
(
val <T> T.foo getfun main() {
Int::foo
}) = 1
x1
fun (main) {
Int::foo
}
val <T> T.foo get() = 1
x1
fun val <T> T.foo get() = 1() {
Int::foo
}
main
x1
fun main() {
Int::foo
}
val fooT> T.< get() = 1
x1
fun main() {
Int::foo
}
val <T> foo.T get() = 1
x1
fun main() {
Int::foo
}
val <T> get.foo T() = 1
x1
fun mainfoo {
Int::()
}
val <T> T.foo get() = 1
x1
fun main() T
val <T> {
Int::foo
}.foo get() = 1
x1
fun mainfoo) {
Int::(
}
val <T> T.foo get() = 1
x1
fun main() {
Intgetfoo
}
val <T> T.foo ::() = 1
x1
fun get() = 1() {
Int::foo
}
val <T> T.foo main
x1
fun mainT) {
Int::foo
}
val <(> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T= T.foo get() > 1
x1
fun {() main
Int::foo
}
val <T> T.foo get() = 1
x1
fun =() {
Int::foo
}
val <T> T.foo get() main 1
x1
T main() {
Int::foo
}
val <T> fun.foo get() = 1
x1
<T>
val fun main() {
Int::foo
} T.foo get() = 1
x1
fun main() {
Int}foo
::
val <T> T.foo get() = 1
x1
fun main:: {
Int()foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
get <T> T.foo val() = 1
x1
fun mainInt::foo {
()
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
1
val <T> T.foo get() = }
x1
fun main() val
{
Int::foo
} <T> T.foo get() = 1
x1
fun main() {
IntTfoo
}
val <T> ::.foo get() = 1
x1
< main() {
Int::foo
}
val funT> T.foo get() = 1
x1
T
val <fun main() {
Int::foo
}> T.foo get() = 1
x1
fun main() {
Int::foo
T
val <T> }.foo get() = 1
x1
fun main() {
Int::foo
}
val <=> T.foo get() T 1
x1
fun main() {
Int::foo
}
val <T> 1.foo get() = T
x1
fun mainT {
Int::foo
}
val <T> ().foo get() = 1
x1
fun main() {
Int::T
}
val <T> foo.foo get() = 1
x1
fun main() {
Int::foo
}
val getT> T.foo <() = 1
x1
fun main() .
Int::foo
}
val <T> T{foo get() = 1
x1
fun main(val {
Int::foo
}
) <T> T.foo get() = 1
x1
val main() {
Int::foo
}
fun <T> T.foo get() = 1
x1
fun main() {
val <T> T.foo get() = 1
}
Int::foo
x1
fun mainval {
Int::foo
}
() <T> T.foo get() = 1
x1
get
val <T> T.foo fun main() {
Int::foo
}() = 1
x1
fun main() {
Int::foo
}
val <T> =.foo get() T 1
x1
<
val fun main() {
Int::foo
}T> T.foo get() = 1
x1
fun main() {
val
}
Int::foo <T> T.foo get() = 1
x1
fun main() {
Int::val <T> T.foo get() = 1
}
foo
x1
fun main() {
Int::T
}
val <foo> T.foo get() = 1
x1
fun main() <T>
Int::foo
}
val { T.foo get() = 1
x1
fun main() {
<
}
val Int::fooT> T.foo get() = 1
x1
fun main() {
Int::foo
}
val =T> T.foo get() < 1
x1
fun ()main {
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() ::
Int{foo
}
val <T> T.foo get() = 1
x1
fun main() {
::Intfoo
}
val <T> T.foo get() = 1
x1
fun main>) {
Int::foo
}
val <T( T.foo get() = 1
x1
fun main<T> {
Int::foo
}
val () T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.( getfoo) = 1
x1
fun main() {
Int::foo
}
val <T> T.foo =() get 1
x1
fun main1 {
Int::foo
}
val <T> T.foo get() = ()
x1
fun main() {
Int::foo
}
val . T<T>foo get() = 1
x1
Int main() {
fun::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <>T T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T)foo get(. = 1
x1
fun main() {
T::foo
}
val <T> Int.foo get() = 1
x1
fun mainget() = 1 {
Int::foo
}
val <T> T.foo ()
x1
fun main() {
Int::foo
}
val <T> T.foo get)( = 1
x1
=
val <T> T.foo get() fun main() {
Int::foo
} 1
x1
fun main({ )
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.= get() foo 1
x1
fun mainval <T> T.foo get() = 1) {
Int::foo
}
(
x1
fun main() {
Int::foo
}
val <T> T=foo get() . 1
x1
fun main() val <T> T.foo get() = 1
{
Int::foo
}
x1
( mainfun) {
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get=) ( 1
x1
fun main() {
val <T> T.foo get() = 1::foo
}
Int
x1
fun main() {
Int::>
}
val <Tfoo T.foo get() = 1
x1
fun main() .
val <T> T{
Int::foo
}foo get() = 1
x1
fun main() {
Int::foo
}
val .T> T<foo get() = 1
x1
fun main() {
get
}
val <T> T.foo Int::foo() = 1
x1
fun main() {
Int1foo
}
val <T> T.foo get() = ::
x1
fun main() T
Int::foo
}
val <T> {.foo get() = 1
x1
fun (() {
Int::foo
}
val <T> T.foo getmain) = 1
x1
fun main() {
Int::foo
}
val <Tfoo T.> get() = 1
x1
fun main() {
Int::foo
<
val }T> T.foo get() = 1
x1
get main() {
Int::foo
}
val <T> T.foo fun() = 1
x1
fun main() {
<T>
}
val Int::foo T.foo get() = 1
x1
fun main() {
1::foo
}
val <T> T.foo get() = Int
x1
fun main() {
>::foo
}
val <TInt T.foo get() = 1
x1
fun main() {
Int::foo
}
foo <T> T.val get() = 1
x1
fun main() {
Int<foo
}
val ::T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get(1 = )
x1
fun main() {
T
}
val <Int::foo> T.foo get() = 1
x1
fun mainget) {
Int::foo
}
val <T> T.foo (() = 1
x1
fun main< {
Int::foo
}
val ()T> T.foo get() = 1
x1
get() = 1
val <T> T.foo fun main() {
Int::foo
}
x1
fun main() {
(
}
val <T> T.foo getInt::foo) = 1
x1
T main() {
Int::foo
}
val <fun> T.foo get() = 1
x1
fun main() {
IntTfoo
}
val <::> T.foo get() = 1
x1
fun foo() {
Int::main
}
val <T> T.foo get() = 1
x1
fun main(Int {
)::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <.> TTfoo get() = 1
x1
fun T() {
Int::foo
}
val <main> T.foo get() = 1
x1
) main() {
Int::foo
}
val <T> T.foo get(fun = 1
x1
( main() {
Int::foo
}
val <T> T.foo getfun) = 1
x1
fun main() {
Int::foo
}
val get() = 1 T.foo <T>
x1
{
Int::foo
} main() fun
val <T> T.foo get() = 1
x1
:: main() {
Intfunfoo
}
val <T> T.foo get() = 1
x1
fun main() get
Int::foo
}
val <T> T.foo {() = 1
x1
fun main} {
Int::foo
()
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get1) = (
x1
fun main() {
Int::foo
}
T <T> val.foo get() = 1
x1
fun main() {
Int::foo
}
val <)> T.foo get(T = 1
x1
fun T() {
Int::foo
}
val <T> main.foo get() = 1
x1
fun mainT {
Int::foo
}
val <()> T.foo get() = 1
x1
fun main() >
val <T{
Int::foo
} T.foo get() = 1
x1
fun main. {
Int::foo
}
val <T> T()foo get() = 1
x1
fun main() {
.::foo
}
val <T> TIntfoo get() = 1
x1
fun main.) {
Int::foo
}
val <T> T(foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get(= ) 1
x1
fun Int::foo() {
main
}
val <T> T.foo get() = 1
x1
fun main() foo
val <T> T.{
Int::foo
} get() = 1
x1
fun main() {
Int::foo
}
val <T1 T.foo get() = >
x1
fun main() {
Int::foo
}
val <TT >.foo get() = 1
x1
fun main(1 {
Int::foo
}
val <T> T.foo get() = )
x1
fun main() {
Int::foo
}
val ( T.foo get<T>) = 1
x1
fun main() {
Int::foo
}
val <T> T1foo get() = .
x1
fun main() {
T::foo
}
val <Int> T.foo get() = 1
x1
fun main= {
Int::foo
}
val <T> T.foo get() () 1
x1
fun main() {
Int::foo
}
val <T> Tfoo. get() = 1
x1
Int::foo main() {
fun
}
val <T> T.foo get() = 1
x1
fun main{
Int::foo
} ()
val <T> T.foo get() = 1
x1
fun main() {
Int::=
}
val <T> T.foo get() foo 1
x1
fun main() {
Intget() = 1foo
}
val <T> T.foo ::
x1
fun main() {
Int::foo
val
} <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.get() = 1 foo
x1
fun main() {
Int)foo
}
val <T> T.foo get(:: = 1
x1
fun mainval) {
Int::foo
}
( <T> T.foo get() = 1
x1
fun main() {
Int::foo
T
val <}> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <get() = 1> T.foo T
x1
fun main() {
Int::foo
>
val <T} T.foo get() = 1
x1
fun mainT) {
Int::foo
}
val <T> (.foo get() = 1
x1
fun main() {
Int::foo
}
> <Tval T.foo get() = 1
x1
fun main=) {
Int::foo
}
val <T> T.foo get() ( 1
x1
fun main(:: {
Int)foo
}
val <T> T.foo get() = 1
x1
fun main)( {
Int::foo
}
val <T> T.foo get() = 1
x1
foo main() {
Int::fun
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
( <T> T.foo getval) = 1
x1
fun main() {
foo
}
val <T> T.Int::foo get() = 1
x1
fun main(T {
Int::foo
}
val <T> ).foo get() = 1
x1
fun main() <
Int::foo
}
val {T> T.foo get() = 1
x1
fun main() {
Int::foo
}
= <T> T.foo get() val 1
x1
fun main() {
Int::foo
}
val foo T.<T> get() = 1
x1
fun main<T>) {
Int::foo
}
val ( T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> Tgetfoo .() = 1
x1
fun main() {
Int::foo
)
val <T> T.foo get(} = 1
x1
fun main() T
val <{
Int::foo
}> T.foo get() = 1
x1
fun main() foo
Int::foo
}
val <T> T.{ get() = 1
x1
fun mainInt {
()::foo
}
val <T> T.foo get() = 1
x1
fun main() (
Int::foo
}
val <T> T.foo get{) = 1
x1
fun main1) {
Int::foo
}
val <T> T.foo get() = (
x1
fun main() {
Int::foo
.
val <T> T}foo get() = 1
x1
fun mainget() = 1) {
Int::foo
}
val <T> T.foo (
x1
fun val() {
Int::foo
}
main <T> T.foo get() = 1
x1
= main() {
Int::foo
}
val <T> T.foo get() fun 1
x1
fun main() {
Int::foo
}
val <(> T.foo getT) = 1
x1
. main() {
Int::foo
}
val <T> Tfunfoo get() = 1
x1
fun main() {
Int::}
foo
val <T> T.foo get() = 1
x1
.
val <T> Tfun main() {
Int::foo
}foo get() = 1
x=
fun main() {
Int::foo
}
val <T> isInitialized.foo get() = 1
x'
fun main() {
Int::foo
}
var p = 2 < 1
x6
fun main() {
Int::foo
}
val <T> String.foo get() = 1
x7
fun main() {
Int::foo
}
val <T> T.Exception get() = 1
xd
fun main() {
    val inner = Outer.Nested().bar()
    return inner.foo()
}
val <T> T.foo get() = 1
x4
fun main() {
::ByteArray
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> T.foo get() = this
x3
fun main() {
Int::foo
}
val <T> T.foo private set
x:
fun main() {
Int::foo
}
val <T: Number?> T.foo get() = 1
x2
fun main() {
Int::Test
}
val <T> T.foo get() = 1
x6
fun main() {
Int::foo
}
val <T> Double.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> Long.foo get() = 1
x4
fun main() {
Int::String
}
val <T> T.foo get() = 1
x/
fun main() {
Int::A
}
val <T> T.foo get() = 1
x1
fun main() {
Int::box
}
val <T> T.foo get() = 1
x1
fun main() {
set::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> T.foo get() = "OK"
x'
fun main() {
Int::foo
}
val ok = "OK"
x/
fun main() {
l::foo
}
val <T> T.foo get() = 1
y Ÿ
fun main() {
    val l = ArrayList<Int>()
    l.add(1)
    var x = l[0]
    x += 1
    l[0] += 1
    if (l[0] != 2) return "Fail: ${l[0]}"
    if (x != 2) return "Fail: $x}"
    return "OK"
}
val <T> T.foo get() = 1
x4
fun main() {
String::foo
}
val <T> T.foo get() = 1
x0
fun box() {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() {
::bar
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> T.String get() = 1
x/
fun main() {
Int::c
}
val <T> T.foo get() = 1
y ô
fun main() {
    (::topLevel)()
    (A::member)(A())
    (A::ext)(A())
    return if (state == "123") "OK" else "Fail $state"
}
val <T> T.foo get() = 1
x:
fun main() {
::createContainer
}
val <T> T.foo get() = 1
x2
fun main() {
bar2::foo
}
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> T.foo get() = z.y
x@
fun main() {
Int::foo
}
val result: String by Delegate("Fail")
xD
fun main(args: Array<String>) {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() {
Z::xx
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> Byte.foo get() = 1
y ©
fun main() {

  fun local():Int {
    return 10;
  }

  class A {
      val test = local()
  }

  return if (A().test == 10) "OK" else "fail"
}
val <T> T.foo get() = 1
x?
fun main() {
Int::foo
}
val <T> (() -> String)?.foo get() = 1
x+
fun main() {
Int::foo
}
val a = A("Fail")
x0
fun main() {
v1::foo
}
val <T> T.foo get() = 1
y Ñ
fun main() {
      if (i != j && a[i] == a[j]) {
        duplicate = true
        break@loop
      }
    }
val <T> T.foo get() = 1
x0
fun maina {
Int::foo
}
val <T> T.foo get() = 1
x2
fun TItem() {
Int::foo
}
val <T> T.foo get() = 1
x/
fun main() {
a::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> Char.foo get() = 1
yV
fun main() {
    val property = ::pr
    if (property.get() != Box("first")) return "Fail value: ${property.get()}"
    if (property.name != "pr") return "Fail name: ${property.name}"
    property.set(Box("second"))
    if (property.get().value != "second") return "Fail value 2: ${property.get()}"
    return "OK"
}
val <T> T.foo get() = 1
x0
fun main() {
Int::ub
}
val <T> T.foo get() = 1
x1
fun main() {
Int::Any
}
val <T> T.foo get() = 1
x1
fun main() {
Int::get
}
val <T> T.foo get() = 1
y
fun main() {
    var y: String = "OK"

    var materializer: (() -> String)? = null

    when (val x = y) {
        "OK" -> materializer = { x }
        else -> return "x is $x"
    }

    y = "Fail"

    return materializer!!.invoke()
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val foo = buildFoo({})
x/
fun main() {
t::foo
}
val <T> T.foo get() = 1
xX
fun main() {
Int::foo
}
val <T> kotlin.reflect.KMutableProperty0<String>.foo get() = 1
x0
fun main() {
Int::el
}
val <T> T.foo get() = 1
x4
fun main() {
Int::Double
}
val <T> T.foo get() = 1
x6
fun main() {
Int::foo
}
val <T> JClass.foo get() = 1
x1
fun Char() {
Int::foo
}
val <T> T.foo get() = 1
xD
fun main() {
Pair<String, String>::first
}
val <T> T.foo get() = 1
xv
fun main() {
    val s = doTest()
    return if (s == "1:2;2:3;3:4;") "OK" else "fail: $s"
}
val <T> T.foo get() = 1
x/
fun main() {
Int::T
}
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> T.list4 get() = 1
x1
fun main() {
Int::foo
}
val <T> T.foo get() = a
x/
fun main() {
Int::foo
}
val <T> T.x get() = 1
x3
fun main() {
barg1::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::a2
}
val <T> T.foo get() = 1
y Ç
fun main() {
      var s = ""
      for ((a, b) in l) {
        s += "$a:$b;"
      }
      return s
  }
val <T> T.foo get() = 1
x2
fun main() {
Int::foo
}
val <T> T.Long get() = 1
y Ç
fun main() {
    var x = 0
    run { x++ }
    run { ++x }
    return if (x == 2) "OK" else "Fail: $x"
}
val <T> T.foo get() = 1
x5
fun main() {
Int::reflect
}
val <T> T.foo get() = 1
x?
fun main() {
Int::foo
}
val <T> T.foo get() = "Base.baseProp"
x/
fun main() {
Int::t
}
val <T> T.foo get() = 1
xM
fun main() {
Int::foo
}
val <T> T.foo get() = 42.also { result += "A.ep," }
x0
fun main() {
Int::foo
}
val values2 = values()
x/
fun main() {
y::foo
}
val <T> T.foo get() = 1
x.
fun m() {
Int::foo
}
val <T> T.foo get() = 1
x/
fun main() {
Int::R
}
val <T> T.foo get() = 1
x2
fun main() {
::compare
}
val <T> T.foo get() = 1
xP
fun main() {
Int::foo
}
val <T> T.foo get() {
        return this@getter
    }
x7
fun main() {
Int::foo
}
val <T> T.KProperty get() = 1
x|
fun main() {
Int::foo
}
val <T> T.foo get() = object : Your() {
            override val your = back
        }.foo() + "K"
x/
fun main() {
Int::n
}
val <T> T.foo get() = 1
x9
fun main() {
Int::foo
}
val <T> Result<*>.foo get() = 1
x-
fun main() {
::OK
}
val <T> T.foo get() = 1
y ≥
fun main() {
    val z = Z().test()
    if (z != "A") return "fail 1: $z"

    val f = Z().field
    if (f != "F") return "fail 2: $f"

    return "OK"
}
val <T> T.foo get() = 1
x2
fun ULong() {
Int::foo
}
val <T> T.foo get() = 1
x0
fun foo() {
Int::foo
}
val <T> T.foo get() = 1
x/
fun main() {
x::foo
}
val <T> T.foo get() = 1
x7
fun main() {
Int::foo
}
val <T> Boolean.foo get() = 1
x.
fun x() {
Int::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Double::foo
}
val <T> T.foo get() = 1
x1
fun main() {
add::foo
}
val <T> T.foo get() = 1
y Ï
// WITH_RUNTIME
// KJS_WITH_FULL_RUNTIME
fun foo(): Array<Boolean> {
    return arrayOf(
        0.0 / 0 == 0.0 / 0,
        0.0F > -0.0F,
        0.0.equals(-0.0),
        (0.0 / 0.0).equals(1.0 / 0.0)
    )
}
val <T> T.foo get() = 1
x3
fun String() {
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::Int
}
val <T> T.foo get() = 1
x'
fun main() {
Int::foo
}
val s: String
x/
fun main() {
Int::foo
}
val <T> T.i get() = 1
x0
fun main() {
Int::an
}
val <T> T.foo get() = 1
x1
fun main() {
box::foo
}
val <T> T.foo get() = 1
x?
fun main() {
Int::foo
}
val <T> Short.Companion.foo get() = 1
x.
fun main() {
::foo
}
val <T> T.foo get() = 1
x4
fun main() {
result::foo
}
val <T> T.foo get() = 1
x%
fun main() {
Int::foo
}
val K = "K"
x1
fun main() {
Int::foo
}
val <T> T.bar get() = 1
y å
fun main() {
    for (x in FloatArray(5)) {
        if (x != 0.toFloat()) return "Fail $x"
    }
    return "OK"
}
val <T> T.foo get() = 1
x2
fun main() {
Char::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> Unit.foo get() = 1
xM
fun main() {
            z += this + left
        }
val <T> T.foo get() = 1
xU
fun main() { if (a != b) throw AssertionError("$a != $b") }
val <T> T.foo get() = 1
xO
fun box(): String {
    Foo.s.param
    return "OK"
}
val <T> T.foo get() = 1
x1
fun main() {
::Nested
}
val <T> T.foo get() = 1
x3
fun main() {
MaxUI::foo
}
val <T> T.foo get() = 1
x2
fun main() {
Int::mult
}
val <T> T.foo get() = 1
x6
fun main() {
this@A::value
}
val <T> T.foo get() = 1
xs
fun main() {
    return if (apply( 5, {arg: Int -> arg + 13 } ) == 18) "OK" else "fail"
}
val <T> T.foo get() = 1
xu
fun box(): String {
    val a = A()
    val x = A::foo
    x(a, "OK")
    return a.result
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val c = a.value.hashCode()
x1
fun main() {
Int::foo
}
val <T> i.foo get() = 1
x0
fun str() {
Int::foo
}
val <T> T.foo get() = 1
x'
fun main() ok
val <T> T.foo get() = 1
x/
fun main() {
Foo::x
}
val <T> T.foo get() = 1
x5
fun main() {
Int::foo
}
val <T> Array.foo get() = 1
x.
fun A() {
Int::foo
}
val <T> T.foo get() = 1
x0
fun res() {
Int::foo
}
val <T> T.foo get() = 1
x/
fun fn() {
Int::foo
}
val <T> T.foo get() = 1
xE
fun getUserIdFromEnvironment() {
Int::foo
}
val <T> T.foo get() = 1
x@
fun main() {
Int::foo
}
val vf: String.() -> String = { this }
x0
fun main() {
Int::foo
}
val <T> T.id get() = 1
x;
fun main() {
Int::foo
}
val <T> T.foo get() = field + "K"
xU
fun main() {
Int::foo
}
val <T> T.foo get() = throw UnsupportedOperationException()
x/
fun main() {
Int::foo
}
val s = M().doTest(l)
x5
fun main() {
toUByte::foo
}
val <T> T.foo get() = 1
x/
fun f2() {
Int::foo
}
val <T> T.foo get() = 1
x6
fun main() {
Int::foo
}
val <T> OsType.foo get() = 1
y ≠
fun box(): String {
    val sorted = arrayListOf("1", "3", "2").sorted()
    return if (sorted != arrayListOf("1", "2", "3")) "$sorted" else "OK"
}
val <T> T.foo get() = 1
x&
fun main() {
Int::foo
}
val d: D = z
x>
fun main() {
Int::foo
}
val i = 1 as Int         //exception
x2
fun main() {
Int::test
}
val <T> T.foo get() = 1
x_
fun box(): String {
    fun A.foo() = "OK"
    return (A::foo)(A())
}
val <T> T.foo get() = 1
x1
fun size() {
Int::foo
}
val <T> T.foo get() = 1
x3
fun main() {
Int::Float
}
val <T> T.foo get() = 1
y
fun main() {
    val bDefault = A().B()
    val b = A().B("aa", 66, "cc")
    if (bDefault.a == "a" && bDefault.b == 55 && bDefault.c == "c") {
        if (b.a == "aa" && b.b == 66 && b.c == "cc") {
            return "OK"
        }
    }
    return "fail"
}
val <T> T.foo get() = 1
x/
fun main() {
f::bar
}
val <T> T.foo get() = 1
x/
fun main() {
Int::foo
}
val <T> T.s get() = 1
x$
fun main() {
Int::foo
}
var s = ""
x5
fun main() {
Int::foo
}
val <T> T.foo get() = false
x3
fun result() {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() Name("K")
val <T> T.foo get() = 1
x6
fun eq(a: Z?, b: Z) = a == b
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> T.foo get() = A()
x1
fun Host() {
Int::foo
}
val <T> T.foo get() = 1
x>
fun main() {
       b[i] = i++
    }
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> k.foo get() = 1
x6
fun main() {
Int::foo
}
val <T> _field.foo get() = 1
x/
fun main() {
C::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val a2: Short? = 1 + 1
x1
fun main() {
A::Inner
}
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> T.Local get() = 1
x/
fun main() {
Int::x
}
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> Int.foo get() = 1
xK
fun visit(a:String, b:String="") : String = b + a
val <T> T.foo get() = 1
xB
fun main() {
    return box is Box<*>;
}
val <T> T.foo get() = 1
x3
fun main() {
Int::foo
}
val <T> add.foo get() = 1
y ∂
fun main() {
    return object : Foo {
        override fun xyzzy(x: Any?): String {
           (x as? Bar)?.bar()
            return "OK"
        }
    }
}
val <T> T.foo get() = 1
x9
fun main() {
Int::foo
}
val <T> () -> Int.foo get() = 1
x1
fun Long() {
Int::foo
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> a.foo get() = 1
x0
fun sum() {
Int::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> T.result get() = 1
x6
fun main() {
Int::foo
}
val <T> result.foo get() = 1
x2
fun main() {
::Wrapper
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> C.foo get() = 1
x1
fun from() {
Int::foo
}
val <T> T.foo get() = 1
x5
fun contents() {
Int::foo
}
val <T> T.foo get() = 1
x+
fun main() {
Int::foo
}
val c = AsInt(42)
x1
fun main() {
Any::foo
}
val <T> T.foo get() = 1
x0
fun main() {
f1::foo
}
val <T> T.foo get() = 1
x.
fun T() {
Int::foo
}
val <T> T.foo get() = 1
x@
fun main() {
Int::foo
}
val <T> T.foo get() = value is Failure
x5
fun main() {
Derived::foo
}
val <T> T.foo get() = 1
x4
fun main() {
Int::foo
}
val <T> test.foo get() = 1
yÅ
fun box(): String {
    val list1 = ArrayList<Int>()
    val range1 = 3..9
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<Int>(3, 4, 5, 6, 7, 8, 9)) {
        return "Wrong elements for 3..9: $list1"
    }

    val list2 = ArrayList<Int>()
    val range2 = 3.toByte()..9.toByte()
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<Int>(3, 4, 5, 6, 7, 8, 9)) {
        return "Wrong elements for 3.toByte()..9.toByte(): $list2"
    }

    val list3 = ArrayList<Int>()
    val range3 = 3.toShort()..9.toShort()
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<Int>(3, 4, 5, 6, 7, 8, 9)) {
        return "Wrong elements for 3.toShort()..9.toShort(): $list3"
    }

    val list4 = ArrayList<Long>()
    val range4 = 3L..9L
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<Long>(3, 4, 5, 6, 7, 8, 9)) {
        return "Wrong elements for 3L..9L: $list4"
    }

    val list5 = ArrayList<Char>()
    val range5 = 'c'..'g'
    for (i in range5) {
        list5.add(i)
        if (list5.size > 23) break
    }
    if (list5 != listOf<Char>('c', 'd', 'e', 'f', 'g')) {
        return "Wrong elements for 'c'..'g': $list5"
    }

    return "OK"
}
val <T> T.foo get() = 1
x<
fun main() {
Int::foo
}
val <T> () -> String.foo get() = 1
y ﬁ
fun main() {
    val any: Any? = when (1) {
        x -> null
        else -> Any()
    }

    // Must not be NPE here
    val hashCode = any?.hashCode()

    return hashCode?.toString() ?: "OK"
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> A.foo get() = 1
x+
fun main() {
Int::foo
}
val obj = C().D()
x.
fun main() {
L::xx
}
val <T> T.foo get() = 1
x1
fun main() {
Int::foo
}
val <T> T.add get() = 1
y §
fun box(): String {
    val ok: String? = "OK"
    var res = ""

    do {
        res += ok ?: break
    } while (false)

    return res
}
val <T> T.foo get() = 1
x7
fun main() {
Int::foo
}
val <T> toShort.foo get() = 1
x2
fun main() {
A::Nested
}
val <T> T.foo get() = 1
x/
fun ss() {
Int::foo
}
val <T> T.foo get() = 1
x%
fun main() {
Int::foo
}
val bar = x
x1
fun IFoo() {
Int::foo
}
val <T> T.foo get() = 1
y Å
fun main() {
Int::foo
}
val x = when (val s = peek()) {
        "A" -> "OK"
        "B" -> "B"
        else -> "other $s"
    }
x3
fun main() {
A(0)::lmao
}
val <T> T.foo get() = 1
xq
fun main() {
Int::foo
}
val <T> T.foo get() {
        return {
            this@getter
        }.invoke()
    }
x<
fun main() {
  return "$a $b $c"
}
val <T> T.foo get() = 1
xO
fun main() {
Int::foo
}
val <T> LowPriorityInOverloadResolution.foo get() = 1
x-
fun main() {
a::g
}
val <T> T.foo get() = 1
x1
val <T> T.foo get() = 1
Int::foo
}
fun main() {
x.
fun main() {
Int::foo
}
val <T> T.foo () = 1
x0
fun main() {
Int::foo
}
val <T> .foo get() = 1
x0fun main() {
Int::foo
}
val <T> T.foo get() = 1
x%
fun main() 
val <T> T.foo get() = 1
x/
fun main {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() {
Int::foo
}
val <T> T. get() = 1
x0
fun main( {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() {
Int::foo
}
val  T.foo get() = 1
x-
fun () {
Int::foo
}
val <T> T.foo get() = 1
x.
fun main() {
Int::foo
}
 <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val T> T.foo get() = 1
x0
fun main() {
Int::foo

val <T> T.foo get() = 1
x0
fun main() {
Int::foo}
val <T> T.foo get() = 1
x0
fun main() {Int::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.foo get()= 1
x0
fun main() {
Int::foo
}
val <T> T.foo get() =1
x0
fun main() {
Int::foo
}
val <T>T.foo get() = 1
x)
fun main() {

}
val <T> T.foo get() = 1
x/
fun main() {
Intfoo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <> T.foo get() = 1
x.
fun main() {
Int::
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.foo get( = 1
x

val <T> T.foo get() = 1
x(
fun main() {
Int::foo
}
val <T> T.foo 
x0
fun main(){
Int::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.foo get) = 1
x0
fun main() {
Int::foo
}
val<T> T.foo get() = 1
x0
funmain() {
Int::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.foo get() = 1x0
fun main() {
Int::foo
}
val <T> T.foo get() = 
x
fun main() {
Int::foo
}

x0
fun main() {
Int::foo
}val <T> T.foo get() = 1
x.
 main() {
Int::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> Tfoo get() = 1
x0
fun main) {
Int::foo
}
val <T> T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.foo get()  1
x0
fun main() {
Int::foo
}
val <T T.foo get() = 1
x0
fun main() {
Int::foo
}
val <T> T.fooget() = 1
x0
fun main() 
Int::foo
}
val <T> T.foo get() = 1
x%

Int::foo
}
val <T> T.foo get() = 1
ˇˇ