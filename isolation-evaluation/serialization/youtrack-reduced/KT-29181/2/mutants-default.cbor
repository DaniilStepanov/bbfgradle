¿iexportTaggdefaultnoriginalSamplex&
fun 
(): Int {
x = lit@ return@lit
}
gmutantsŸx[

val z = true
try
{fun 
(): Int {
x = lit@ return@lit
}}
catch(e: Exception){}
finally{}

x[
fun 
(): Int 
val u = true
try
{{
x = lit@ return@lit
}}
catch(e: Exception){}
finally{}

x[
fun 
(): Int {

val p = true
try
{x = lit@ return@lit}
catch(e: Exception){}
finally{}

}
xI
fun 
(): 
val i = true
if (i) {Int} else {Int}
 {
x = lit@ return@lit
}
xG
fun 
(): Int {

val n = true
if (n) {x} else {x}
 = lit@ return@lit
}
x[
fun 
(): Int {
x 
val k = true
try
{=}
catch(e: Exception){}
finally{}
 lit@ return@lit
}
x\
fun 
(): Int {
x = 
val l = false
try
{lit@ return@lit}
catch(e: Exception){}
finally{}

}
xd
fun 
(): Int {
x = lit@ 
val p = false
when (p) {
 true -> {return@lit}
 else -> {return@lit}
}

}
xJ
fun 
(): Int {
x = 
val u = true
if (u) {lit@} else {lit@}
 return@lit
}
x[
fun 
(): Int {
x = lit@ return
val g = true
try
{@lit}
catch(e: Exception){}
finally{}

}
x(
fun 
(): Int {
x = (lit@) return@lit
}
x(
fun 
(): Int {
x = lit@ return@lit!!
}
x)
fun 
(): (Int)? {
x = lit@ return@lit
}
x&
fun 
(): Int {
x @lit lit@ return=
}
x&
fun 
:)( Int {
x = lit@ return@lit
}
x&
fun 
(x: Int {
) = lit@ return@lit
}
x&
fun 
(){ Int :
x = lit@ return@lit
}
x&
fun 
(): {
x = lit@ return@lit
} Int
x&
fun 
(): Int {
x = lit@ return@lit
}
x&
fun 
(): lit@ return@lit {
x = Int
}
x&
@lit 
(): Int {
x = lit@ returnfun
}
x&
fun 
(): Int {
@lit = lit@ returnx
}
x&
lit@ 
(): Int {
x = fun return@lit
}
x&
fun 
(): Int return@lit
x = lit@ {
}
x&
fun 
(): Int {
x @ lit@ return=lit
}
x&
fun 
(}: Int {
x = lit@ return@lit
)
x&
fun 
(): Int {
x lit@ return@lit =
}
x&
fun 
x: Int {
() = lit@ return@lit
}
x&
fun 
()lit Int {
x = lit@ return@:
}
x&
fun 
return@lit): Int {
x = lit@ (
}
x&
Int 
(): fun {
x = lit@ return@lit
}
x&
fun 
(): Int {
x = lit@ return@}
lit
x&
fun 
(): Int {
x } lit@ return@lit
=
x&
fun 
(): = {
x Int lit@ return@lit
}
x&
fun 
(): Int {
lit@ = x return@lit
}
x&
fun 
(): return@lit {
x = lit@ Int
}
x&
fun 
(): Int {
x = litreturn @@lit
}
x&
lit 
(): Int {
x = lit@ return@fun
}
x&
return 
(): Int {
x = lit@ fun@lit
}
x&
fun 
(): Int lit
x = lit@ return@{
}
x&
fun 
(:) Int {
x = lit@ return@lit
}
x&
fun 
{
x = lit@ return@lit
}: Int ()
x&
fun 
(): Int {
lit = lit@ return@x
}
x&
fun 
(): return {
x = lit@ Int@lit
}
x&
fun 
(){
x = lit@ return@lit
} Int :
x&
fun 
x = lit@ return@lit: Int {
()
}
x&
fun 
(): x = lit@ return@lit {
Int
}
x&
fun 
@): Int {
x = lit@ return(lit
}
x&
fun 
()} Int {
x = lit@ return@lit
:
x&
fun 
(): Int {
x return@lit lit@ =
}
x&
fun 
(): Int {
= x lit@ return@lit
}
x&
fun 
{): Int (
x = lit@ return@lit
}
x&
fun 
(): Int @lit
x = lit@ return{
}
x&
fun 
(x = lit@ return@lit: Int {
)
}
x&
fun 
}): Int {
x = lit@ return@lit
(
x&
fun 
(): Int {
@ = lit@ returnxlit
}
x&
fun 
(): @lit {
x = lit@ returnInt
}
x&
fun 
(): Int x = lit@ return@lit
{
}
x&
lit@ return@lit 
(): Int {
x = fun
}
x&
fun 
(Int: ) {
x = lit@ return@lit
}
x&
fun 
(): } {
x = lit@ return@lit
Int
x&
fun 
(): x {
Int = lit@ return@lit
}
x&
fun 
(): Int {
}
x = lit@ return@lit
x&
fun 
(): Int {
x return lit@ =@lit
}
x&
fun 
(): Int {
x = return@lit lit@
}
x&
fun 
x = lit@ return@lit): Int {
(
}
x&
fun 
(): Int @
x = lit{ return@lit
}
x&
fun 
(lit@: Int {
x = ) return@lit
}
x&
fun 
({
x = lit@ return@lit
}: Int )
x&
fun 
(): Int {
x @ lit= return@lit
}
x&
fun 
(): Int {
x = @lit returnlit@
}
x&
fun 
(): Int @
x = lit@ return{lit
}
x&
fun 
@lit: Int {
x = lit@ return()
}
x&
fun 
()lit@ return@lit Int {
x = :
}
x&
fun 
(): lit@ {
x = Int return@lit
}
x&
fun 
return: Int {
x = lit@ ()@lit
}
x&
fun 
(lit: Int {
x = )@ return@lit
}
x&
fun 
(): Int {
x lit@ = return@lit
}
x&
fun 
lit: Int {
x = lit@ return@()
}
x&
fun 
()lit Int {
x = :@ return@lit
}
x&
fun 
()lit@ Int {
x = : return@lit
}
x&
fun 
(): lit {
x = lit@ return@Int
}
x&
fun 
(return@lit: Int {
x = lit@ )
}
x&
fun 
=): Int {
x ( lit@ return@lit
}
x&
fun 
(): { Int
x = lit@ return@lit
}
x&
fun 
()@ Int {
x = lit: return@lit
}
x&
fun 
}: Int {
x = lit@ return@lit
()
x&
fun 
(): Int {
x = @@ returnlitlit
}
x&
} 
(): Int {
x = lit@ return@lit
fun
x&
fun 
(): Int {
x = } return@lit
lit@
x&
fun 
{
x = lit@ return@lit
}): Int (
x&
fun 
(): Int {
x = @lit@ returnlit
}
x&
fun 
Int: () {
x = lit@ return@lit
}
x&
fun 
(): Int {
x lit lit@ return@=
}
x&
fun 
()Int : {
x = lit@ return@lit
}
x&
fun 
lit: Int {
x = ()@ return@lit
}
x&
fun 
(): Int {
x = return@lit@ lit
}
x&
fun 
(=: Int {
x ) lit@ return@lit
}
x&
fun 
()@lit Int {
x = lit@ return:
}
x&
fun 
(return: Int {
x = lit@ )@lit
}
x&
fun 
Int): ( {
x = lit@ return@lit
}
x&
fun 
(): Int {
x = lit@ return}
@lit
x&
fun 
(): Int {
x = litlit return@@
}
x&
fun 
(): Int lit@ return@lit
x = {
}
x&
fun 
(): Int {
x lit =@ return@lit
}
x&
fun 
(): @ {
x = litInt return@lit
}
x&
fun 
(): Int {
@ = litx return@lit
}
x&
fun 
()= Int {
x : lit@ return@lit
}
x&
fun 
(): Int {
return = lit@ x@lit
}
x&
fun 
@lit): Int {
x = lit@ return(
}
x&
fun 
=: Int {
x () lit@ return@lit
}
x&
fun 
()@ Int {
x = lit@ return:lit
}
x&
fun 
{: Int ()
x = lit@ return@lit
}
x&
fun 
(): Int {
x = lit@ @litreturn
}
x&
fun 
(): Int }
x = lit@ return@lit
{
x&
fun 
(): lit {
x = Int@ return@lit
}
x&
{
x = lit@ return@lit
} 
(): Int fun
x&
fun 
(@lit: Int {
x = lit@ return)
}
x&
( 
fun): Int {
x = lit@ return@lit
}
x&
fun 
(): @ {
x = lit@ returnIntlit
}
x&
fun 
(): Int {
x = lit return@lit@
}
x&
fun 
(): Int {
x = lit@ returnlit@
}
x&
fun 
(): Int {
x = lit@ lit@return
}
x&
= 
(): Int {
x fun lit@ return@lit
}
x&
fun 
(): Int {
x = lit@ return}lit
@
x&
fun 
(): Int return
x = lit@ {@lit
}
x&
fun 
return@lit: Int {
x = lit@ ()
}
x&
@ 
(): Int {
x = litfun return@lit
}
x&
fun 
lit): Int {
x = (@ return@lit
}
x&
fun 
@): Int {
x = lit( return@lit
}
x&
: 
()fun Int {
x = lit@ return@lit
}
x&
fun 
(): Int lit@
x = { return@lit
}
x&
fun 
(): Int {
x = lit@lit return@
}
x&
fun 
(lit@ return@lit: Int {
x = )
}
x&
fun 
lit@ return@lit): Int {
x = (
}
x&
fun 
:() Int {
x = lit@ return@lit
}
x&
) 
(fun: Int {
x = lit@ return@lit
}
x&
fun 
@: Int {
x = lit() return@lit
}
x&
fun 
(): Int {
x = return@ lit@lit
}
x&
fun 
lit@: Int {
x = () return@lit
}
x&
fun 
(): Int {
x = lit@ }
return@lit
x&
fun 
(): Int {
lit = x@ return@lit
}
x&
fun 
(): Int {
x = return lit@@lit
}
x&
lit 
(): Int {
x = fun@ return@lit
}
x&
fun 
(): Int {
return@lit = lit@ x
}
x&
fun 
(): Int x
{ = lit@ return@lit
}
x&
fun 
()x Int {
: = lit@ return@lit
}
x&
fun 
(): Int {
x = }@ return@lit
lit
x&
fun 
()x = lit@ return@lit Int {
:
}
x&
fun 
return): Int {
x = lit@ (@lit
}
x&
x 
(): Int {
fun = lit@ return@lit
}
x&
fun 
(): Int {
x = @ returnlit@lit
}
x&
fun 
(lit: Int {
x = lit@ return@)
}
x&
fun 
lit@ return@lit: Int {
x = ()
}
x&
fun 
(): Int {
x = }
lit@ return@lit
x&
fun 
(): Int {
x = @lit return@lit
}
x+
fun 
(): Int {
String = lit@ return@lit
}
x)
fun 
(): Int {
this = lit@ return@lit
}
x$
fun 
(): Int {
x = lit@ return@C
}
x)
fun 
(): IcLong {
x = lit@ return@lit
}
xa
fun 
(): Int {
    holder += "getShape1()"
    mainShape = Shape("fail")
    return mainShape
}
w
fun box() = X.B.value
x(
fun 
(): Int {
x = @Outer return@lit
}
x(
fun 
(): Int {
x = range@ return@lit
}
x8
fun 
(): Int {
            s += "WrongCatch"
        }
x+
fun 
(): Int {
x = @testFun4 return@lit
}
x'
fun 
(): Int {
x = lit@ return "OK"
}
x3
fun 
(): Int {
L(1234L)::test.invoke() != 1234L
}
x
fun 
(): Int {
r ?: value
}
x$
fun 
(): Int {
x = lit@ return@A
}
x(
fun 
(): Int {
box = lit@ return@lit
}
x$
fun 
(): Int {
x = lit@ return@N
}
x(
fun 
(): Int {
Foo = lit@ return@lit
}
x&
fun 
(): Int {
x = lit@ return a.a
}
x)
fun 
(): Int {
x = @getter return@lit
}
x$
fun 
(): Int {
x = x@ return@lit
}
x'
fun 
(): Int {
x == lit@ return@lit
}
x+
fun 
(): Int {
x = lit@ return@iterator
}
xm
fun 
(): Int {
    return when (x) {
        1 -> 5
        2 -> 6
        3 -> 7
        else -> 8
    }
}
x(
fun 
(): Int {
x = list1@ return@lit
}
x+
fun 
(): Int {
toByte = lit@ return@lit
}
x'
fun 
(): Int {
x ++ lit@ return@lit
}
x'
fun 
(): Int {
x = lit@ returnloop@
}
x3
fun 
(): Int {
AssertionError = lit@ return@lit
}
y Ö
fun box(): String {
    var xs by Del(intArrayOf(1, 2, 3))
    var sum = 0
    for (x in xs) {
        sum = sum * 10 + x
        xs = intArrayOf(4, 5, 6)
    }
    return if (sum == 123) "OK" else "Fail: $sum"
}
x$
fun 
(): Int {
x = @X return@lit
}
x(
fun 
(): Int {
x = label@{ it("K") }
}
x!
fun 
(): Int {
x = x@ (1 + 2)
}
y–
fun box(): String {
    val list1 = ArrayList<Int>()
    for (i in MaxI..MaxI) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<Int>(MaxI)) {
        return "Wrong elements for MaxI..MaxI: $list1"
    }

    val list2 = ArrayList<Int>()
    for (i in MaxB..MaxB) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<Int>(MaxB.toInt())) {
        return "Wrong elements for MaxB..MaxB: $list2"
    }

    val list3 = ArrayList<Int>()
    for (i in MaxS..MaxS) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<Int>(MaxS.toInt())) {
        return "Wrong elements for MaxS..MaxS: $list3"
    }

    val list4 = ArrayList<Long>()
    for (i in MaxL..MaxL) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<Long>(MaxL)) {
        return "Wrong elements for MaxL..MaxL: $list4"
    }

    val list5 = ArrayList<Char>()
    for (i in MaxC..MaxC) {
        list5.add(i)
        if (list5.size > 23) break
    }
    if (list5 != listOf<Char>(MaxC)) {
        return "Wrong elements for MaxC..MaxC: $list5"
    }

    return "OK"
}
x0
fun 
(): Int {
    Derived()
    return "OK"
}
x$
fun 
(): Int {
x = @B return@lit
}
x/
fun 
(): Int {
properties = lit@ return@lit
}
xf
fun 
(): Int {
x = loop@ for (i in from..to) {
        if (c >= 5) continue@loop
        c++
    }
}
x&
fun 
(): Int {
x < lit@ return@lit
}
x$
fun 
(): Int {
x = @a return@lit
}
xa
fun 
(): Int {
x = f@{
        if (a > 0)
          return@f "OK"
        else "Fail 1"
    }
}
x$
fun 
(): Int {
x = @N return@lit
}
x%
fun 
(): Int {
backing = newValue
}
x+
fun 
(): Int {
x = lit@ return@Derived1
}
x5
fun 
(): Int {
x = l2@ if (l3@ true) s1 else null
}
x$
fun 
(): Int {
x = lit@ return s
}
x
fun 
(): Int {
'A' + 1
}
xp
fun box(): String {
    val server = MyHttpServer()
    server.start()
    return server.logger.toString()!!
}
x)
fun 
(): Int {
obj1 = lit@ return@lit
}
x'
fun 
(): Int {
x .. lit@ return@lit
}
x)
fun 
(): Int {
Long = lit@ return@lit
}
y ·
fun box(): String {
    val div = u / ua
    if (div != ub) throw AssertionError("$div")

    val divInt = u / uai
    if (div != ub) throw AssertionError("$div")

    return "OK"
}
x&
fun 
(): Int {
x = @Bar return@lit
}
x$
fun 
(): Int {
x = @C return@lit
}
x&
fun 
(): Int {
a = lit@ return@lit
}
t
fun 
(): Int a + b
y „
fun 
(): Int {
  val c = A()
  if(c.prop != 1) return "fail get"
  c.prop = 2
  if (c.prop != 2) return "fail set"
  return "OK"
}
n
fun foo() {}
x(
fun 
(): Int {
x = lit@ return@Outer
}
x%
fun 
(): Int {
5 in 1 .. abs(-10)
}
x'
fun 
(): Int {
bx = lit@ return@lit
}
x$
fun 
(): Int {
x = @A return@lit
}
x#
fun 
(): Int {
hashMap[""] = ""
}
x@
fun wrap1(x: String): Z1? = if (x.length == 0) null else Z1(x)
x
fun 
(): Int {
data.size-1
}
x,
fun 
(): Int {
message = lit@ return@lit
}
xl
fun 
(): Int {
x = loop@ while(true) {
        when (v) {
            1, 2 -> break@loop
        }
    }
}
x(
fun 
(): Int {
o === Float.Companion
}
y ã
fun box() : String {
    val a = IntArray (5)
    var i = 0
    var sum = 0
    for(el in 0..4) {
       a[i] = i++
    }
    for (el in a) {
        sum = sum + el
    }
    if(sum != 10) return "a failed"

    return "OK"
}
x-
fun 
(): Int {
CONSTANT = lit@ return@lit
}
x+
fun 
(): Int {
    return D().E().foo()
}
x&
fun 
(): Int {
x ! lit@ return@lit
}
x$
fun 
(): Int {
x = a@ return@lit
}
x)
fun 
(): Int {
x = lit@ return@getter
}
x'
fun 
(): Int {
x = lit@ return@run1
}
x
fun 
(): Int {
a.o + a.k
}
x$
fun 
(): Int {
x = lit@ return@a
}
x
fun 
(): Int {
MinL + 2
}
x&
fun 
(): Int {
x - lit@ return@lit
}
x'
fun 
(): Int {
x != lit@ return@lit
}
y Ç
fun 
(): Int {
    val s = StringBuilder()

    for ((_, x) in arr.withIndex()) {
        s.append("$x;")
    }

    val ss = s.toString()
    return if (ss == "a;b;c;d;") "OK" else "fail: '$ss'"
}
x&
fun 
(): Int {
t = lit@ return@lit
}
u
fun 
(): Int { ok }
x
fun 
(): Int {
y == null
}
x$
fun 
(): Int {
x = A@ return@lit
}
x'
fun 
(): Int {
x !! lit@ return@lit
}
xG
fun 
(): Int {
        xs.add(i)
        if (xs.size > 3) break
    }
y £
fun box(): String {
    val result = (A::Inner)((::A)(), 111).result + (A::Inner)(A(), 222).result
    if (result != 333) return "Fail $result"
    return "OK"
}
xM
fun modify(ref: KMutableProperty0<Foo>) {
    var a by ref
    a = Foo(1)
}
x 
fun box() = C().foo().result()
x-
fun 
(): Int {
x = @withLabel1 return@lit
}
x
fun 
(): Int {
4 > 3
}
y ñ
fun 
(): Int {
x = loop@ for (color in arr) {
        when (color) {
            Color.RED -> return color
            Color.GREEN -> break@loop
            Color.BLUE -> if (arr.size == 1) return color else continue@loop
        }
    }
}
x`
fun 
(): Int {
x = test1@ for(i in 1..2) {
        continue@test1
        return false
    }
}
yë
fun box(): String {
    val list1 = ArrayList<UInt>()
    for (i in MaxUI..MinUI) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<UInt>()) {
        return "Wrong elements for MaxUI..MinUI: $list1"
    }

    val list2 = ArrayList<ULong>()
    for (i in MaxUL..MinUL) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<ULong>()) {
        return "Wrong elements for MaxUL..MinUL: $list2"
    }

    return "OK"
}
x_
fun 
(): Int {
x = loop@ for (i in a) {
        if (c >= 5) continue@loop
        c++
    }
}
xf
fun 
(): Int {
        return "Wrong elements for 3u.toUShort()..8u.toUShort() step 2: $list3"
    }
x-
fun 
(): Int {
iterator = lit@ return@lit
}
x$
fun 
(): Int {
x = lit@ returnb@
}
x+
fun 
(): Int {
x = lit@ return "O".calc
}
x$
fun 
(): Int {
x = d@ return@lit
}
x*
fun Char.Companion.MAX() = MAX_SURROGATE
x
fun 
(): Int {
x = foo@ x
}
x*
fun 
(): Int {
list1 != listOf<UInt>()
}
x%
fun f(b : Int.(Int)->Int) = 1?.b(1)
x'
fun 
(): Int {
x += lit@ return@lit
}
x/
fun 
(): Int {
result != "<clinit>ij<init>"
}
x@
fun box() : String {
    TestClass({}).run()
    return "OK"
}
x+
fun 
(): Int {
length = lit@ return@lit
}
y•
fun 
(): Int {
    val a1: Byte = -1
    val a2: Short = -1
    val a3: Int = -1
    val a4: Long = -1
    val a5: Double = -1.0
    val a6: Float = -1f

    if (a1 != (-1).toByte()) return "fail 1"
    if (a2 != (-1).toShort()) return "fail 2"
    if (a3 != -1) return "fail 3"
    if (a4 != -1L) return "fail 4"
    if (a5 != -1.0) return "fail 5"
    if (a6 != -1f) return "fail 6"

    return "OK"
}
x)
fun 
(): Int {
Test = lit@ return@lit
}
x(
fun 
(): Int {
x = OUTER@ return@lit
}
x,
fun 
(): Int {
x = lit@ return@TestClass
}
x#
fun 
(): Int {
z.foo("") != "Z"
}
x(
fun 
(): Int {
x = test1@ return@lit
}
x3
fun 
(): Int {
x.key != "56" || x.value != "OK"
}
y ‘
fun 
(): Int {
    var i : MyClass? 
    i = MyClass()
    val j = ++i

    return if (j == null && null == i) "OK" else "fail i = $i j = $j"
}
x%
fun 
(): Int {
j == 11 && 11 == i
}
x$
fun 
(): Int {
x = lit@ return@B
}
xC
fun 
(): Int {
    var x = ""
    run { x = "OK" }
    return x
}
x6
fun 
(): Int {
Z.Z1.foo("")                != "Z1"
}
x+
fun 
(): Int {
result = lit@ return@lit
}
x8
fun 
(): Int {
    fun OK() {}

    return ::OK.name
}
x-
fun 
(): Int {
x = lit@ return@withLabel1
}
x&
fun 
(): Int {
x = lit@ return@foo
}
x$
fun 
(): Int {
x = z@ return@lit
}
y œ
fun 
(): Int {
    val result = A(23).s
    if (result != "OK") return "fail: $result"
    if (log != "logged") return "fail log: $log"

    return "OK"
}
x,
fun 
(): Int {
toShort = lit@ return@lit
}
x&
fun 
(): Int {
g = lit@ return@lit
}
x'
fun 
(): Int {
x = res2@ return@lit
}
x*
fun 
(): Int {
MaxUL = lit@ return@lit
}
x%
fun 
(): Int {
x = II@ return@lit
}
x+
fun 
(): Int {
x = lit@ return "fail 3"
}
x2
fun 
(): Int {
5.toByte()..1.toByte() step 255
}
x%
fun 
(): Int {
x = @id return@lit
}
x+
fun 
(): Int {
One().a1[0].fy == "text"
}
x)
fun 
(): Int {
Anno = lit@ return@lit
}
x
fun 
(): Int {
i == Bar.ONE
}
x)
fun 
(): Int {
x = String@ return@lit
}
y î
fun 
(): Int {
        val test = Foo(count, Foo(1, "x", 2), if (count > 0) break else 3)
        if (count > 0) return "Fail: count = $count"
        if (test.toString() != "Foo(0,Foo(1,x,2),3)") return "Fail: ${test.toString()}"
    }
x-
fun 
(): Int {
intRange = lit@ return@lit
}
x&
fun 
(): Int {
u = lit@ return@lit
}
xt
fun foo(): String {
    fun bar(x: String, y: String = x): String {
        return y
    }

    return bar("OK")
}
x,
fun 
(): Int {
x = operation@ return@lit
}
x$
fun 
(): Int {
x = lit@ returnd@
}
x3
fun 
(): Int {
        return s.extension()
    }
x(
fun 
(): Int {
Int = lit@ return@lit
}
x;
fun 
(): Int {
x = l@ fun (): Boolean { return@l true }
}
yE
operator fun <T : Any> T?.iterator() = object : MyIterator<T> {
    private var hasNext = this@iterator != null

    override fun hasNext() = hasNext

    override fun next() : T {
        if (hasNext) {
            hasNext = false
            return this@iterator!!
        }
        throw NoSuchElementException()
    }
}
x'
fun 
(): Int {
x = loop@ return@lit
}
x,
fun 
(): Int {
x = lit@ return@unaryPlus
}
x1
fun 
(): Int {
    return ZImpl2().test("OK")
}
x*
fun 
(): Int {
Float = lit@ return@lit
}
y ž
fun ListTag.test(list: List<String>) {
    for (item in list) {
        item() {
            a {
                text = item
            }
        }
    }
}
y ˜
fun 
(): Int {
x = loop@ for (i in a.indices) {
    for (j in a.indices) {
      if (i != j && a[i] == a[j]) continue@loop
    }
    return a[i]
  }
}
x$
fun 
(): Int {
x = lit@ returnl@
}
x'
fun 
(): Int {
x = test@ return@lit
}
x(
operator fun iterator() = It(from, to)
x1
fun 
(): Int {
x = @AWrapperFabric return@lit
}
x#
fun 
(): Int {
changeLong != 1L
}
x&
fun 
(): Int {
x = @Foo return@lit
}
xW
fun box(): String {
    val a = A()
    val x = A::foo
    x(a)
    return a.result
}
y ô
// KJS_WITH_FULL_RUNTIME
fun isDigit(a: Int) : String {
    val aa = ArrayList<Int> ()
    aa.add(239)

    return when(a) {
      in aa -> "array list"
      in 0..9 -> "digit"
     !in 0..100 -> "not small"
      else -> "something"
    }
}
x&
fun 
(): Int {
C = lit@ return@lit
}
x'
fun 
(): Int {
x = @self return@lit
}
x*
fun 
(): Int {
x = lit@ return@rangeTo
}
x
fun 
(): Int {
x = l1@ "s"
}
x'
fun 
(): Int {
ax = lit@ return@lit
}
xa
fun box(): String {
    val c = A(object: B {}).c
    return if (c == 3) "OK" else "fail: $c"
}
x'
fun 
(): Int {
5.valThisRef1() != 5
}
y ©
// KJS_WITH_FULL_RUNTIME
fun box(): String {
    val l = ArrayList<Int>()
    l.add(1)
    val x = l[0].hashCode()
    if (x != 1) return "Fail: $x}"
    return "OK"
}
x5
fun box(): String = OHolderAlias.O + KHolderAlias.K
xX
fun box(): String {
    return if ((arrayOf(1, 2, 3)::get)(1) == 2) "OK" else "Fail"
}
x$
fun 
(): Int {
x = l@ return@lit
}
x&
fun 
(): Int {
x = lit@ returnfoo@
}
y Ø
fun 
(): Int {
x = OUTER@while (true) {
        var x = ""
        try {
            do {
                x = x + break@OUTER
            } while (true)
        } finally {
            return "OK"
        }
    }
}
x_
fun 
(): Int {
        return "Wrong elements for 9.toByte() downTo 3.toByte(): $list2"
    }
x.
fun 
(): Int {
x = runNoInline@ return@lit
}
x&
fun 
(): Int {
A = lit@ return@lit
}
xH
fun 
(): Int {
        val g = f as () -> Int
        sum += g()
    }
x(
fun 
(): Int {
x = lit@ returnlabel@
}
xA
fun 
(): Int {
        for(i in 0..this)
            op()
    }
x,
fun 
(): Int {
equals3 = lit@ return@lit
}
x,
fun 
(): Int {
x = ArrayList@ return@lit
}
x
fun 
(): Int {
x > y
}
x
fun 
(): Int {
this + 1
}
x(
fun 
(): Int {
s1.string + s2.string
}
x&
fun 
(): Int {
P = lit@ return@lit
}
x)
fun 
(): Int {
getA = lit@ return@lit
}
x+
fun 
(): Int {
x = contains@ return@lit
}
x*
fun 
(): Int {
Actor = lit@ return@lit
}
x3
fun 
(): Int {
            return param
        }
y “
fun 
(): Int {
    if (Outer().Inner("OK").box() != "OK") return "Fail"
    val x: Outer.Inner<String> = Outer().Inner("OK")
    return x.box()
}
x*
fun 
(): Int {
index = lit@ return@lit
}
x.
fun 
(): Int {
x = lit@ return@innerGetter
}
w
fun foo(t: T): String
x'
fun 
(): Int {
My = lit@ return@lit
}
x)
fun 
(): Int {
x = WINTER@ return@lit
}
x-
fun 
(): Int {
expected = lit@ return@lit
}
x
fun 
(): Int {
f.foo() != 3
}
x6
fun 
(): Int {
result != "<clinit>ik<init>j<init>"
}
x&(): Int {
fun 

x = lit@ return@lit
}
x&fun 

(): Int {
x = lit@ return@lit
}
x&}
fun 
(): Int {
x = lit@ return@lit

x%
fun 
(): Int {
x = lit@ return@lit}
x%fun 
(): Int {
x = lit@ return@lit
}
x%
fun 
():Int {
x = lit@ return@lit
}
w
fun 
(): Int {
x = 
}
x#
fun 
():  {
x = lit@ return@lit
}
x%
fun 
(): Int {
x = lit@ return@lit
}x 
fun 
(): Int {
x = lit@ @lit
}
o
fun 
(): Int 
x$
fun 
: Int {
x = lit@ return@lit
}
x$
fun(): Int {
x = lit@ return@lit
}
x%
fun 
(): Int {
 = lit@ return@lit
}
b

x#
fun 
(): Int {
x = lit@ return@
}
x%
fun 
(: Int {
x = lit@ return@lit
}
x
fun 
(): Int {
x = lit@ 
}
x%
fun 
(): Int {
x= lit@ return@lit
}
x%
fun 
(): Int 
x = lit@ return@lit
}
x%
fun 
(): Int {
x = lit@ returnlit
}
x%
fun 
(): Int {
x  lit@ return@lit
}
x#
fun 
(): Int {
x = @ return@lit
}
s
fun 
(): Int {

}
x%
fun 
): Int {
x = lit@ return@lit
}
x%
fun 
(): Int {
x =lit@ return@lit
}
x"
fun 
(): Int {
x =  return@lit
}
x%
fun 
(): Int {x = lit@ return@lit
}
x%
fun 
() Int {
x = lit@ return@lit
}
x%
fun 
(): Int {
x = lit return@lit
}
x#
 
(): Int {
x = lit@ return@lit
}
x"
fun 
(): Int {
x = lit@ return
}
x%
fun 
(): Int{
x = lit@ return@lit
}
x%
fun 
(): Int {
x = lit@ return@lit

x%
fun 
(): Int {
x = lit@return@lit
}
ÿÿ