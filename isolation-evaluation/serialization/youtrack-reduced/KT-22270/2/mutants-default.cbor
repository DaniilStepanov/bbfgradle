¿iexportTaggdefaultnoriginalSamplex&
fun 
(): List
 {
plop@ return@plop
}
gmutantsŸxk

val m = false
if (m) {fun 
(): List
 {
plop@ return@plop
}} else {fun 
(): List
 {
plop@ return@plop
}}

x\
fun 
(): List
 
val a = false
if (a) {{
plop@ return@plop
}} else {{
plop@ return@plop
}}

xX
fun 
(): List
 {

val c = false
if (c) {plop@ return@plop} else {plop@ return@plop}

}
x[
fun 
(): 
val j = true
try
{List}
catch(e: Exception){}
finally{}

 {
plop@ return@plop
}
x\
fun 
(): List
 {
plop@ 
val t = false
try
{return@plop}
catch(e: Exception){}
finally{}

}
x^
fun 
(): List
 {

val p = true
when (p) {
 true -> {plop@}
 else -> {plop@}
}
 return@plop
}
xK
fun 
(): List
 {
plop@ return
val c = true
if (c) {@plop} else {@plop}

}
x(
fun 
(): List
 {
(plop@ return@plop)
}
x)
fun 
(): (List)?
 {
plop@ return@plop
}
x&
fun 
(): plop@ return@plop
 {
List
}
x&
fun 
(): List
 return@plop
plop@ {
}
x&
fun 
(): List
 {
plop@ return@plop
}
x&
fun 
(): List
 {
plop@ plop@return
}
x&
plop@ return@plop 
(): List
 {
fun
}
x&
plop 
(): List
 {
fun@ return@plop
}
x&
fun 
plop): List
 {
(@ return@plop
}
x&
fun 
(): @plop
 {
plop@ returnList
}
x&
fun 
(): plop@
 {
List return@plop
}
x&
return@plop 
(): List
 {
plop@ fun
}
x&
fun 
(return@plop: List
 {
plop@ )
}
x&
fun 
(): {
 List
plop@ return@plop
}
x&
fun 
(): return@plop
 {
plop@ List
}
x&
fun 
()return List
 {
plop@ :@plop
}
x&
fun 
(): {
plop@ return@plop
}
 List
x&
fun 
plop): List
 {
plop@ return@(
}
x&
fun 
()} List
 {
plop@ return@plop
:
x&
fun 
(): List
 {
@plop return@plop
}
x&
fun 
(): return
 {
plop@ List@plop
}
x&
fun 
(): List
 {
@ returnplop@plop
}
x&
fun 
@: List
 {
plop() return@plop
}
x&
fun 
()plop@ List
 {
: return@plop
}
x&
fun 
(): plop
 {
plop@ return@List
}
x&
fun 
()@ List
 {
plop: return@plop
}
x&
fun 
(): List
 @plop
plop@ return{
}
x&
plop@ 
(): List
 {
fun return@plop
}
x&
fun 
List: ()
 {
plop@ return@plop
}
x&
fun 
()plop List
 {
plop@ return@:
}
x&
fun 
@plop): List
 {
plop@ return(
}
x&
fun 
()List :
 {
plop@ return@plop
}
x&
fun 
()return@plop List
 {
plop@ :
}
x&
@plop 
(): List
 {
plop@ returnfun
}
x&
fun 
List): (
 {
plop@ return@plop
}
x&
fun 
(){ List
 :
plop@ return@plop
}
x&
fun 
}: List
 {
plop@ return@plop
()
x&
fun 
(plop@ return@plop: List
 {
)
}
x&
fun 
(): List
 {
return plop@@plop
}
x&
() 
fun: List
 {
plop@ return@plop
}
x&
fun 
return): List
 {
plop@ (@plop
}
x&
fun 
(): List
 {
return@plop plop@
}
x&
fun 
(@plop: List
 {
plop@ return)
}
x&
fun 
(List: )
 {
plop@ return@plop
}
x&
fun 
(): plop
 {
List@ return@plop
}
x&
fun 
(): List
 {
plop return@plop@
}
x&
fun 
(@: List
 {
plop) return@plop
}
x&
fun 
(): List
 {
} return@plop
plop@
x&
List 
(): fun
 {
plop@ return@plop
}
x&
fun 
(): }
 {
plop@ return@plop
List
x&
fun 
plop@): List
 {
( return@plop
}
x&
fun 
(){
plop@ return@plop
} List
 :
x&
fun 
plop@: List
 {
() return@plop
}
x&
fun 
plop@ return@plop: List
 {
()
}
x&
fun 
(): List
 {
plop@ @plopreturn
}
x&
fun 
(): List
 {
plop@plop return@
}
x&
fun 
(): List
 {
return@plop@ plop
}
x&
fun 
(): List
 plop@
{ return@plop
}
x&
fun 
@): List
 {
plop( return@plop
}
x&
fun 
(): List
 {
plop} return@plop
@
x&
fun 
(): List
 {
@plop returnplop@
}
x&
fun 
(): List
 @
plop{ return@plop
}
x&
@ 
(): List
 {
plop@ returnfunplop
}
x&
fun 
(): @
 {
plop@ returnListplop
}
x&
fun 
(): List
 return
plop@ {@plop
}
x&
fun 
@plop: List
 {
plop@ return()
}
x&
fun 
(): List
 @
plop@ return{plop
}
x&
fun 
@: List
 {
plop@ return()plop
}
x&
fun 
()plop@ return@plop List
 {
:
}
x&
fun 
(): @
 {
plopList return@plop
}
x&
fun 
{
plop@ return@plop
}: List
 ()
x&
fun 
plop@ return@plop): List
 {
(
}
x&
fun 
(}: List
 {
plop@ return@plop
)
x&
} 
(): List
 {
plop@ return@plop
fun
x&
plop 
(): List
 {
plop@ return@fun
}
x&
fun 
(:) List
 {
plop@ return@plop
}
x&
fun 
(return: List
 {
plop@ )@plop
}
x&
fun 
({: List
 )
plop@ return@plop
}
x&
@ 
(): List
 {
plopfun return@plop
}
x&
fun 
()plop List
 {
:@ return@plop
}
x&
fun 
(): List
 }
plop@ return@plop
{
x&
fun 
(): List
 plop@ return@plop
{
}
x&
fun 
()@plop List
 {
plop@ return:
}
x&
fun 
(): List
 {
plop@ return}
@plop
x&
fun 
return: List
 {
plop@ ()@plop
}
x&
return 
(): List
 {
plop@ fun@plop
}
x&
{
plop@ return@plop
} 
(): List
 fun
x&
fun 
(): List
 {
@plop@ returnplop
}
x&
fun 
(): List
 {
plop@ returnplop@
}
x&
fun 
(plop: List
 {
plop@ return@)
}
x&
fun 
)(: List
 {
plop@ return@plop
}
x&
fun 
(): List
 {
}@ return@plop
plop
x&
: 
()fun List
 {
plop@ return@plop
}
x&
fun 
(): List
 {
plop@ }
return@plop
x&
fun 
return@plop): List
 {
plop@ (
}
x&
fun 
:)( List
 {
plop@ return@plop
}
x&
fun 
{
plop@ return@plop
}): List
 (
x&
fun 
(plop: List
 {
)@ return@plop
}
x&
fun 
@): List
 {
plop@ return(plop
}
x&
fun 
({
plop@ return@plop
}: List
 )
x&
fun 
(): List
 {
plop@ return}plop
@
x&
( 
fun): List
 {
plop@ return@plop
}
x&
fun 
(): List
 {
plopreturn@plop @
}
x&
fun 
(): List
 {
@@ returnplopplop
}
x&
fun 
plop: List
 {
plop@ return@()
}
x&
{ 
(): List
 fun
plop@ return@plop
}
x&
fun 
(): List
 {
plopreturn @@plop
}
x&
fun 
:() List
 {
plop@ return@plop
}
x&
fun 
(): List
 {
}
plop@ return@plop
x&
fun 
(plop@: List
 {
) return@plop
}
x&
fun 
(): List
 {
plopplop return@@
}
x&
) 
(fun: List
 {
plop@ return@plop
}
x#
fun 
(): List
 {
@B return@plop
}
x
fun foo(t: T, u: U) = "A"
x#
fun 
(): List
 {
plop@ return@C
}
x*
fun 
(): List
 {
plop@ return@Derived1
}
x&
fun 
(): List
 {
plop@ return@self
}
x.
fun anyEqeq(x: Any, y: Any) =
        x == y
x'
fun 
(): ULong
 {
plop@ return@plop
}
x(
fun 
(): String
 {
plop@ return@plop
}
x#
fun 
(): List
 {
plop@ return@A
}
x#
fun 
(): T
 {
plop@ return@plop
}
x&
fun 
(): List
 {
plop@ return@loop
}
x#
fun 
(): List
 {
plop@ returnx@
}
yq
fun box(): String {
    val list1 = ArrayList<UInt>()
    val range1 = (MaxUI - 2u)..MaxUI
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<UInt>(MaxUI - 2u, MaxUI - 1u, MaxUI)) {
        return "Wrong elements for (MaxUI - 2u)..MaxUI: $list1"
    }

    val list2 = ArrayList<ULong>()
    val range2 = (MaxUL - 2u)..MaxUL
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<ULong>(MaxUL - 2u, MaxUL - 1u, MaxUL)) {
        return "Wrong elements for (MaxUL - 2u)..MaxUL: $list2"
    }

    return "OK"
}
x&
fun 
(): List
 {
plop@ return@run1
}
x%
fun 
(): List
 {
plop@ return@Foo
}
x(
fun 
(): List
 {
@getter return@plop
}
x
fun 
(): List
 Test.ok()
xS
fun box(): String {
  val c = C()
  if (c.f != 610) return "fail"
  return "OK"
}
x
fun 
(): List
 {
foo@ x
}
x*
fun Any.isUInt(): Boolean = this is UInt
x#
fun 
(): List
 {
@C return@plop
}
x
fun 
(): List
 {
x@ (1 + 2)
}
x$
fun 
(): List
 {
@id return@plop
}
x%
fun 
(): List
 {
Int@ return@plop
}
x#
fun 
(): List
 {
plop@ return@B
}
x%
fun 
(): List
 {
plop@ returnfoo@
}
x#
fun 
(): a
 {
plop@ return@plop
}
x2
fun 
(): List
 {
plop@ return receiver.block()
}
x4
fun 
(): List
 {
plop@ return TestClass().test()
}
x+
fun 
(): withParam
 {
plop@ return@plop
}
x(
fun 
(): result
 {
plop@ return@plop
}
x#
fun 
(): b
 {
plop@ return@plop
}
x+
fun 
(): List
 {
plop@ return@unaryPlus
}
x'
fun 
(): Float
 {
plop@ return@plop
}
x(
fun 
(): List
 {
plop@ return "fail"
}
x-
fun 
(): List
 {
invokeOrder@ return@plop
}
xj
fun 
(): List
 {
loop@ while(true) {
        when (v) {
            1, 2 -> break@loop
        }
    }
}
x&
fun 
(): List
 {
list@ return@plop
}
x%
fun 
(): List
 {
@Foo return@plop
}
x#
fun 
(): List
 {
@a return@plop
}
x#
fun 
(): e
 {
plop@ return@plop
}
x$
fun 
(): List
 {
xs@ return@plop
}
x$
fun 
(): List
 {
    return "OK"
}
x#
fun 
(): C
 {
plop@ return@plop
}
x)
fun 
(): List
 {
MyTrait@ return@plop
}
x'
fun 
(): List
 {
test1@ return@plop
}
x%
fun 
(): List
 {
box@ return@plop
}
xW
fun 
(): List
 {
plop@ return when(p) {
        null -> 3
        else -> p!!
    }
}
x#
fun 
(): x
 {
plop@ return@plop
}
x(
fun 
(): string
 {
plop@ return@plop
}
x#
fun 
(): List
 {
y@ return@plop
}
x#
fun 
(): List
 {
plop@ return@a
}
x#
fun 
(): List
 {
@A return@plop
}
x_
fun 
(): List
 {
f@{
        if (a > 0)
          return@f "OK"
        else "Fail 1"
    }
}
x(
fun 
(): Father
 {
plop@ return@plop
}
x%
fun 
(): List
 {
rec@ return@plop
}
x-
fun 
(): containsKey
 {
plop@ return@plop
}
x*
fun 
(): maxUByte
 {
plop@ return@plop
}
x&
fun 
(): List
 {
plop@ return "OK"
}
yŠ
fun 
(): List
 {
    val list1 = ArrayList<UInt>()
    val range1 = (MinUI + 2u) downTo MinUI step 1
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<UInt>(MinUI + 2u, MinUI + 1u, MinUI)) {
        return "Wrong elements for (MinUI + 2u) downTo MinUI step 1: $list1"
    }

    val list2 = ArrayList<UInt>()
    val range2 = (MinUB + 2u).toUByte() downTo MinUB step 1
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<UInt>((MinUB + 2u).toUInt(), (MinUB + 1u).toUInt(), MinUB.toUInt())) {
        return "Wrong elements for (MinUB + 2u).toUByte() downTo MinUB step 1: $list2"
    }

    val list3 = ArrayList<UInt>()
    val range3 = (MinUS + 2u).toUShort() downTo MinUS step 1
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<UInt>((MinUS + 2u).toUInt(), (MinUS + 1u).toUInt(), MinUS.toUInt())) {
        return "Wrong elements for (MinUS + 2u).toUShort() downTo MinUS step 1: $list3"
    }

    val list4 = ArrayList<ULong>()
    val range4 = (MinUL + 2u) downTo MinUL step 1
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<ULong>((MinUL + 2u), (MinUL + 1u), MinUL)) {
        return "Wrong elements for (MinUL + 2u) downTo MinUL step 1: $list4"
    }

    return "OK"
}
x*
fun 
(): reversed
 {
plop@ return@plop
}
x(
fun 
(): Double
 {
plop@ return@plop
}
x&
fun 
(): this
 {
plop@ return@plop
}
x#
fun 
(): List
 {
A@ return@plop
}
x'
fun 
(): Array
 {
plop@ return@plop
}
x.
fun 
(): () -> String
 {
plop@ return@plop
}
x9
fun 
(): List
 {
l@ fun (): Boolean { return@l true }
}
y â
fun box(): String {
    val s = StringBuilder()

    for ((index, x) in "abcd".withIndex()) {
        s.append("$index:$x;")
    }

    val ss = s.toString()
    return if (ss == "0:a;1:b;2:c;3:d;") "OK" else "fail: '$ss'"
}
x(
fun 
(): List
 {
String@ return@plop
}
xJ
fun 
(): List
 {
                    return this@test4
                }
y ¢
// KJS_WITH_FULL_RUNTIME
fun box(): String {
    val l = ArrayList<Int>()
    l.add(1)
    val x = l[0] * 2
    if (x != 2) return "Fail: $x}"
    return "OK"
}
x(
fun 
(): List
 {
Double@ return@plop
}
x+
fun 
(): List
 {
@TestClass return@plop
}
x;
fun 
(): List
 {
plop@ return justPrint(9.compareTo(4))
}
x*
fun 
(): List
 {
@iterator return@plop
}
y ï
fun 
(): List
 {
loop@ for (color in arr) {
        when (color) {
            Color.RED -> return color
            Color.GREEN -> break@loop
            Color.BLUE -> if (arr.size == 1) return color else continue@loop
        }
    }
}
y
// KJS_WITH_FULL_RUNTIME
//WITH_RUNTIME
fun box(): String {
    val a = intArrayOf(1, 2)
    val b = arrayOf("OK")
    if ((a::component2)() != 2) {
        return "fail"
    }

    if ((a::get)(1) != 2) {
        return "fail"
    }

    return (b::get)(0)
}
x#
fun 
(): List
 {
f@ return@plop
}
xN
fun 
(): List
 {
plop@ return if (A(0).toString() == "!") "OK" else "fail"
}
x9
fun 
(): List
 {
    log.append(msg)
    return value
}
x#
fun 
(): f
 {
plop@ return@plop
}
x$
fun 
(): List
 {
nx@ return@plop
}
x%
fun 
(): obj
 {
plop@ return@plop
}
x.
fun box(): String {
    return X.B.value()
}
x&
fun 
(): List
 {
plop@ return "$a"
}
x%
fun 
(): List
 {
@foo return@plop
}
xl
fun box(): String {
    val r = C().test()
    if (r != "test;C.bar") return "fail: $r"

    return "OK"
}
x#
fun 
(): i
 {
plop@ return@plop
}
x*
fun 
(): List
 {
plop@ return@iterator
}
x:
fun 
(): List
 {
plop@ return size?.toString() ?: "OK"
}
x#
fun 
(): List
 {
@f return@plop
}
x&
fun 
(): Intf
 {
plop@ return@plop
}
x1
fun 
(): List
 {
d@ fun (): Int { return@d 4}
}
x'
fun 
(): Local
 {
plop@ return@plop
}
x)
fun 
(): List
 {
plop@ return ++field
}
x+
fun 
(): List
 {
plop@ return@TestClass
}
x'
fun 
(): List
 {
test3@ return@plop
}
x*
fun 
(): List
 {
iterator@ return@plop
}
x*
fun 
(): List
 {
plusZero@ return@plop
}
x#
fun 
(): List
 {
plop@ return@X
}
x$
fun 
(): OK
 {
plop@ return@plop
}
x(
fun 
(): listOf
 {
plop@ return@plop
}
x'
fun 
(): List
 {
@Outer return@plop
}
x&
fun 
(): UInt
 {
plop@ return@plop
}
x^
fun 
(): List
 {
test1@ for(i in 1..2) {
        continue@test1
        return false
    }
}
x)
fun 
(): List
 {
@rangeTo return@plop
}
x,
fun 
(): List
 {
@withLabel1 return@plop
}
x,
fun 
(): deepIsNull
 {
plop@ return@plop
}
xU
fun 
(): List
 {

    if (A("test")._kind != "OK") return "fail"

    return "OK"
}
x,
fun 
(): List
 {
        return "OK"
    }
x)
fun 
(): ordinal
 {
plop@ return@plop
}
x&
fun 
(): List
 {
loop@ return@plop
}
x*
fun 
(): List
 {
plop@ return "Fail 1"
}
x&
fun 
(): List
 {
label@{ it("K") }
}
y –
fun 
(): List
 {
loop@ for (i in a.indices) {
    for (j in a.indices) {
      if (i != j && a[i] == a[j]) continue@loop
    }
    return a[i]
  }
}
x%
fun 
(): Int
 {
plop@ return@plop
}
x'
fun 
(): List
 {
boxed@ return@plop
}
x)
fun 
(): () -> T
 {
plop@ return@plop
}
x#
fun 
(): List
 {
B@ return@plop
}
x#
fun 
(): List
 {
@X return@plop
}
y	
fun box(): String {
    val a = A(42)
    if (a.component1() != 42) return "Fail a: ${a.component1()}"
    
    val b = A(239.toLong())
    if (b.component1() != 239.toLong()) return "Fail b: ${b.component1()}"
    
    val c = A("OK")
    return c.component1()
}
x#
fun 
(): List
 {
@N return@plop
}
x7
fun 
(): List
 {
plop@ return "Failed, test==$test"
}
y š
fun 
(): List
 {
    val o = object : A<Int> {
        override fun foo(t: Int) = if (t == 42) "OK" else "Fail $t"
    }
    return Derived(o).foo(42)
}
x<
fun 
(): List
 {
plop@ return "fail 3:  $p3 ${A.holder}"
}
x1
fun 
(): List
 {
provideDelegate@ return@plop
}
x#
fun 
(): List
 {
plop@ return r
}
yt
// KJS_WITH_FULL_RUNTIME
fun box() : String{
    val set = HashSet<String>()
    set.add("foo")
    val t1 = "foo" in set  // returns true, valid
    if(!t1) return "fail1"
    val t2 = "foo" !in set // returns true, invalid
    if(t2) return "fail2"
    val t3 = "bar" in set  // returns false, valid
    if(t3) return "fail3"
    val t4 = "bar" !in set // return false, invalid
    if(!t4) return "fail4"
    val t5 = when("foo") {
      in set -> true
      else -> false
    }
    if(!t5) return "fail5"
    val t6 = when("foo") {
      !in set -> true
      else -> false
    }
    if(t6) return "fail6"
    return "OK"
}
xr
fun 
(): List
 {
  if(prop != 1) return "fail get"
  prop = 2
  if (prop != 2) return "fail set"
  return "OK"
}
x$
fun 
(): List
 {
a0@ return@plop
}
x&
fun 
(): Int?
 {
plop@ return@plop
}
x&
fun 
(): test
 {
plop@ return@plop
}
x#
fun 
(): List
 {
l@ return@plop
}
xc
fun 
(): List
 {
plop@ return "Wrong elements for (MaxUB - 5u).toUByte()..MaxUB step 3: $list2"
}
xe
fun 
(): List
 {
        return "Wrong elements for 5u.toUByte() downTo 3u.toUByte(): $list2"
    }
y Ó
fun 
(): List
 {
    if (42.let(::Z).x != 42) throw AssertionError()
    if (1234L.let(::L).x != 1234L) throw AssertionError()
    if ("abcdef".let(::S).x != "abcdef") throw AssertionError()

    return "OK"
}
y Î
fun 
(): List
 {
    val res = (1..3).map { it ->
        if (it == 1)
            2
    };

    var result = ""
    for (i in res)
        result += " "
    return if (result == "   ") "OK" else result
}
y ù
fun 
(): List
 {
    if (N().C().test1() != 100) return "test1 fail";
    if (N().C().test2() != 10)  return "test2 fail";
    if (N().C().test3() != 100) return "test3 fail";
    if (N().C().test4() != 100) return "test4 fail";
    return "OK";
}
xs
fun outer() : Int {
        fun inner() : Int = b.foo() //'no such field error' here
        return inner()
    }
xm
fun 
(): List
 {
    val h = A<String?>(null).hashCode()
    if (h != 0) return "Fail $h"
    return "OK"
}
x.
fun 
(): List
 {
        result = "OK"
    }
x
fun 
(): List
 it("K")
y Ì
fun 
(): List
 {
    val x : Array<Array<*>> = arrayOf(arrayOf(1))
    val y : Array<in Array<String>> = x

    if (y.size != 1) return "fail 1"

    y[0] = arrayOf("OK")

    return x[0][0] as String
}
x%
fun 
(): Any
 {
plop@ return@plop
}
x&
fun 
(): Base
 {
plop@ return@plop
}
x&
fun 
(): prop
 {
plop@ return@plop
}
x,
fun 
(): List
 {
plop@ return "fail get"
}
x$
fun 
(): List
 {
        set
    }
x#
fun 
(): List
 {
d@ return@plop
}
xj
fun box(): String {
    if (Test().test() != 1) return "inner getter or setter failed"
    return "OK"
}
x&
fun 
(): List
 {
plop@ returnloop@
}
x9
fun 
(): List
 "ML should satisfy 'is MutableIterable'"
xj
fun 
(): List
 {
plop@ return "Wrong elements for (5.toShort() downTo 3.toShort()).reversed(): $list3"
}
x*
fun 
(): List
 {
plop@ return@testFun4
}
x%
fun 
(): box
 {
plop@ return@plop
}
x)
fun 
(): List
 {
Boolean@ return@plop
}
x
fun 
(): List
 { inner = i }
x+
fun 
(): MIN_VALUE
 {
plop@ return@plop
}
x'
fun 
(): List
 {
plop@ return@Outer
}
x*
fun 
(): callback
 {
plop@ return@plop
}
x#
fun 
(): A
 {
plop@ return@plop
}
xG
fun 
(): List
 {
plop@ return if(j==10 && 11 == i) "OK" else "fail"
}
x#
fun 
(): B
 {
plop@ return@plop
}
xb
fun 
(): List
 {
plop@ return "Wrong elements for 8.toByte() downTo 3.toByte() step 2: $list2"
}
xd
fun 
(): List
 {
loop@ for (i in from..to) {
        if (c >= 5) continue@loop
        c++
    }
}
x#
fun 
(): n
 {
plop@ return@plop
}
y ¼
fun 
(): List
 {
    var r = ""

    r = B().E().bar
    if (r != "OKOKT.baz") return "fail 1; r = $r"

    r = C().D().bar
    if (r != "BOK") return "fail 2; r = $r"

    return "OK"
}
x(
fun 
(): List
 {
plop@ return "FAIL"
}
x$
fun 
(): ss
 {
plop@ return@plop
}
xr
fun box(): String {
    val b = B("OK")
    if (b.foo() != "OK") return "fail: ${b.foo()}"
    return b.foo2()
}
xW
fun 
(): List
 {
        if (true || break) {
            return "OK"
        }
    }
x
fun 
(): List
 {
    }
x$
fun 
(): a2
 {
plop@ return@plop
}
x&
fun 
(): List
 {
p158@ return@plop
}
x%
fun 
(): List
 {
@run return@plop
}
x&
fun 
(): Host
 {
plop@ return@plop
}
x)
fun 
(): List
 {
plop@ return "fail5"
}
x&
fun 
(): List
 {++inc; return field}
x#
fun 
(): List
 {
s@ return@plop
}
x(
fun 
(): List
 {
plop@ return@getter
}
x%
fun 
(): List
 {
foo@ return@plop
}
x+
fun 
(): ArrayList
 {
plop@ return@plop
}
x)
fun 
(): Context
 {
plop@ return@plop
}
y ›
fun 
(): List
 {
plop@ return foo(Season.SPRING) {
        x -> when (x) {
            Season.SPRING -> "OK"
            else -> "fail"
        }
    }
}
x#
fun 
(): M
 {
plop@ return@plop
}
x
fun foo() = Season.SPRING
xP
fun 
(): List
 {
        list3.add(i)
        if (list3.size > 23) break
    }
y»
fun foo(a: Any): Int {
    if (a is IntArray) {
        a.get(0)
        a.set(0, 1)
        a.iterator()
        return a.size
    }
    if (a is ShortArray) {
        a.get(0)
        a.set(0, 1)
        a.iterator()
        return a.size
    }
    if (a is ByteArray) {
        a.get(0)
        a.set(0, 1)
        a.iterator()
        return a.size
    }
    if (a is FloatArray) {
        a.get(0)
        a.set(0, 1.toFloat())
        a.iterator()
        return a.size
    }
    if (a is DoubleArray) {
        a.get(0)
        a.set(0, 1.0)
        a.iterator()
        return a.size
    }
    if (a is BooleanArray) {
        a.get(0)
        a.set(0, false)
        a.iterator()
        return a.size
    }
    if (a is CharArray) {
        a.get(0)
        a.set(0, 'a')
        a.iterator()
        return a.size
    }
    if (a is Array<*>) {
        if (a.size > 0) a.get(0)
        a.iterator()
        return a.size
    }

    return 0
}
x*
fun 
(): List
 {
getValue@ return@plop
}
x(
fun 
(): List
 {
@setter return@plop
}
x9
fun 
(): List
 {
            backingB = value
        }
x'
fun 
(): List
 {
@test1 return@plop
}
x#
fun 
(): s
 {
plop@ return@plop
}
y4
fun 
(): List
 {
    var array : IntArray? = IntArray(10)
    array?.set(0, 3)
    if(array?.get(0) != 3) return "fail"

    var a = arrayOfNulls<Array<String?>>(5)
    var b = arrayOfNulls<String>(1)
    b.set(0, "239")
    a?.set(0, b)

    if(a?.get(0)?.get(0) != "239") return "fail"

    return "OK"
}
xP
fun 
(): List
 {
        list1.add(i)
        if (list1.size > 23) break
    }
y À
fun 
(): List
 {
    val a = FloatArray(5)
    val x = a.iterator()
    var i = 0
    while (x.hasNext()) {
        if (a[i] != x.next()) return "Fail $i"
        i++
    }
    return "OK"
}
x+
fun 
(): List
 {
plop@ return "fail #1"
}
x0
fun 
(): List
 {
AssertionError@ return@plop
}
x$
fun 
(): List
 {
plop@ returnl2@
}
x&
fun 
(): Unit
 {
plop@ return@plop
}
x-
fun 
(): Foo<String>
 {
plop@ return@plop
}
x0
fun 
(): List
 {
@AWrapperFabric return@plop
}
x,
override fun foo(t: String, u: Int) = "Z1"
x
fun 
(): List
 {
l1@ "s"
}
x&
fun 
(): Long
 {
plop@ return@plop
}
x&plop@ return@plop
fun 
(): List
 {

}
x&
 {
(): List
fun 
plop@ return@plop
}
x$
fun 
(): List{
plop@ return@plop
}
x"
fun 
(): 
 {
plop@ return@plop
}
x%
fun 
():List
 {
plop@ return@plop
}
x%
fun 
(): List
 {plop@ return@plop
}
x!
fun 
(): List
 {
 return@plop
}
x!
fun 
(): List
 {
plop@ return
}
x%
fun 
(): List
 
plop@ return@plop
}
x$
fun 
: List
 {
plop@ return@plop
}
x%
fun 
(): List
 {
plop@ returnplop
}
u
fun 
(): List
 {

}
b

x#
 
(): List
 {
plop@ return@plop
}
x$
fun(): List
 {
plop@ return@plop
}
x%
fun 
(): List
 {
plop@return@plop
}
x%
fun 
(): List
 {
plop@ return@plop}
q
fun 
(): List
 
x%
fun 
(): List
 {
plop return@plop
}
x%
fun 
() List
 {
plop@ return@plop
}
x%fun 
(): List
 {
plop@ return@plop
}
x 
fun 
(): List
 {
plop@ @plop
}
x%
fun 
(): List
 {
plop@ return@plop
}x%
fun 
): List
 {
plop@ return@plop
}
x%
fun 
(): List
 {
plop@ return@plop

x"
fun 
(): List
 {
plop@ return@
}
x
fun 
(): List
 {
plop@ 
}
x%
fun 
(: List
 {
plop@ return@plop
}
x"
fun 
(): List
 {
@ return@plop
}
ÿÿ