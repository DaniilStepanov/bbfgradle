øiexportTaggdefaultnoriginalSampleyM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
gmutantsüyJ

val f = true
if (f) {tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}} else {tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}}

sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}

val e = true
try
{sealed class Rope}
catch(e: Exception){}
finally{}

class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope

val n = true
try
{class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}}
catch(e: Exception){}
finally{}

y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = 
val o = true
if (o) {when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}} else {when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}}

sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yä
tailrec fun leafContaining(
val c = true
when (c) {
 true -> {rope: Rope}
 else -> {rope: Rope}
}
, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÉ
tailrec fun leafContaining(rope: Rope, 
val p = false
try
{i: Int}
catch(e: Exception){}
finally{}
): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yr
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (
val t = false
if (t) {rope} else {rope}
) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    
val s = true
try
{inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()}
catch(e: Exception){}
finally{}

}
yÑ
tailrec fun leafContaining(rope: Rope, i: Int): 
val n = true
when (n) {
 true -> {Pair}
 else -> {Pair}
}
<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÂ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> 
val u = false
if (u) {{
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }} else {{
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }}

}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÉ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : 
val m = false
try
{Rope}
catch(e: Exception){}
finally{}
() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÜ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = 
val i = true
when (i) {
 true -> {TODO()}
 else -> {TODO()}
}

}
yÉ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        
val b = false
try
{InnerNode().iter { child ->
            return leafContaining( child,i)
}}
catch(e: Exception){}
finally{}

throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yù
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}

val v = true
when (v) {
 true -> {throw IllegalStateException()}
 else -> {throw IllegalStateException()}
}

    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yú
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(
val f = false
when (f) {
 true -> {f: (child: Rope) -> Boolean}
 else -> {f: (child: Rope) -> Boolean}
}
):Unit = TODO()
}
yÖ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = 
val v = false
when (v) {
 true -> {TODO}
 else -> {TODO}
}
()
}
yÖ
tailrec fun leafContaining(rope: 
val i = false
when (i) {
 true -> {Rope}
 else -> {Rope}
}
, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yq
tailrec fun leafContaining(rope: Rope, i: 
val h = false
if (h) {Int} else {Int}
): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yå
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        
val y = false
when (y) {
 true -> {InnerNode()}
 else -> {InnerNode()}
}
.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().
val h = true
try
{iter { child ->
            return leafContaining( child,i)
}}
catch(e: Exception){}
finally{}

throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yò
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw 
val x = false
when (x) {
 true -> {IllegalStateException()}
 else -> {IllegalStateException()}
}

    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yq
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):
val o = true
if (o) {Unit} else {Unit}
 = TODO()
}
yä
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is 
val c = false
when (c) {
 true -> {InnerNode}
 else -> {InnerNode}
}
 -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yâ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        
val h = true
when (h) {
 true -> {InnerNode}
 else -> {InnerNode}
}
().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yq
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().
val u = true
if (u) {iter} else {iter}
 { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw 
val r = true
try
{IllegalStateException}
catch(e: Exception){}
finally{}
()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : 
val s = true
try
{Rope}
catch(e: Exception){}
finally{}
() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÉ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<
val h = false
try
{Rope}
catch(e: Exception){}
finally{}
, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÉ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, 
val p = true
when (p) {
 true -> {Int}
 else -> {Int}
}
> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter 
val c = true
try
{{ child ->
            return leafContaining( child,i)
}}
catch(e: Exception){}
finally{}

throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yπ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter 
val n = false
when (n) {
 true -> {{ child ->
            return leafContaining( child,i)
}}
 else -> {{ child ->
            return leafContaining( child,i)
}}
}

throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yå
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (
val p = false
when (p) {
 true -> {child: Rope}
 else -> {child: Rope}
}
) -> Boolean):Unit = TODO()
}
yü
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            
val e = true
when (e) {
 true -> {return leafContaining( child,i)}
 else -> {return leafContaining( child,i)}
}

}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yt
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> 
val z = true
if (z) {Boolean} else {Boolean}
):Unit = TODO()
}
yr
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { 
val v = true
if (v) {child} else {child}
 ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            
val g = true
try
{return leafContaining( child,i)}
catch(e: Exception){}
finally{}

}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return 
val i = true
try
{leafContaining( child,i)}
catch(e: Exception){}
finally{}

}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÇ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: 
val r = true
try
{Rope}
catch(e: Exception){}
finally{}
) -> Boolean):Unit = TODO()
}
yè
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return 
val a = false
when (a) {
 true -> {leafContaining}
 else -> {leafContaining}
}
( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÖ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( 
val t = true
when (t) {
 true -> {child}
 else -> {child}
}
,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yn
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,
val j = true
if (j) {i} else {i}
)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when ((rope)) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}!!
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i!!)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): (Pair<Rope, Int>)? = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: (Rope)?, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: (Int)?): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):(Unit)? = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is (InnerNode)? -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : (Rope)?() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<(Rope)?, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, (Int)?> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: ((child: Rope) -> Boolean)?):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> (Boolean)?):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: (Rope)?) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()!!.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) (child: Rope) -> Boolean
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: {):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter ( child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: {child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Rope = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Pair<Rope, Int>() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,Rope)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : i() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
} fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    tailrec
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
Unit
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
} = TODO()
}
yM
tailrec fun leafContaining(rope: Unit, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Rope = TODO()
}
yM
Int fun leafContaining(rope: Rope, i: Int): Pair<Rope, tailrec> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Boolean> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Int):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair(Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException<)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, (child: Rope) -> Boolean> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: Int):Unit = TODO()
}
yM
tailrec fun (leafContainingrope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Intreturn leafContaining( child,i): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            )
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        iter { child ->
            return leafContaining( child,i)
}().InnerNode
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun ((rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : RopeleafContaining) {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: (, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterRopef: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        class.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
InnerNode() InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = Boolean
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int) = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean>:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            ()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Ropereturn leafContaining( child,i) {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter throw IllegalStateException()
{ child ->
            return leafContaining( child,i)
}
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): leafContaining<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Pair( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: InnerNode, i: Int): Pair<Rope, Int> = when (rope) {
    is Rope -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Rope
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: leafContaining( child,i)) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()->iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) . Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode child {
        InnerNode().iter { -> ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: (child: Rope) -> Boolean): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: Int):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    } InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    is
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, ()> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : RopeInt {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: ()child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw class
    }
}
sealed IllegalStateException() Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return =( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit leafContaining TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<}, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
Rope
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<), Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO(Rope
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> Rope
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: iter { child ->
            return leafContaining( child,i)
}): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().Int
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) } Boolean):Unit = TODO()
->
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO}
()
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { : ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(fchild (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<RopeRope Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: ,) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class is InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: leafContaining): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Int( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    ( -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iteris InnerNodef: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContainingRope: Pair<(rope: Rope, i: Int), Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, TODO> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Int()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}()
    }
}
sealed class Rope
IllegalStateException
yM
tailrec fun leafContaining(rope: ), i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(Rope
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: IntRope: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class )
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, Rope: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: i) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
sealed IllegalStateException()
    }
}
throw class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException((child: Rope) -> Boolean
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: )):Unit = TODO()
}
yM
. fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()tailreciter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { (child: Rope) -> Boolean ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: child):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): () = when (rope) {
    is InnerNode -> {
        InnerNodePair<Rope, Int>.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw child: Rope()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (IllegalStateException) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, ,> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( childInti)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): return leafContaining( child,i) = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            Pair<Rope, Int>
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( :,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean)childUnit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = ( whenrope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    Rope InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: is) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> TODO() when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = =
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<iter, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().Rope { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
) class Rope
class InnerNode : Rope(sealed {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): }<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
Pair
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
( fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when tailrecrope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: ., i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()Ropeiter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline f: (child: Rope) -> Boolean iter(fun):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = } (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
when
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Boolean() {
    inline fun iter(f: (child: Rope) -> Rope):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, i> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,Int)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, => Int when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i:
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f) (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodereturn leafContaining( child,i)).iter { child ->
            (
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return throw
}
leafContaining( child,i) IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Ropeinline i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    , fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter Rope
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : { child ->
            return leafContaining( child,i)
}() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
( fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodetailrec).iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<( child,i), Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContainingRope
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(=, i: Int): Pair<Rope, Int> rope: Rope when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (return) {
    is InnerNode -> {
        InnerNode().iter { child ->
            rope leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter Rope()
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : { child ->
            return leafContaining( child,i)
} {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
) fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Ropetailrec -> Boolean):Unit = TODO()
}
yM
tailrec fun {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() leafContaining
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is { -> InnerNode
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterUnit:(f: (child: Rope) -> Boolean) = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pairf: (child: Rope) -> BooleanRope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(<):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode().iter { child ->
            return leafContaining( child,i)
} -> {
        InnerNode
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().Unit { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):iter = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (Rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : child() {
    inline fun iter(f: (Rope: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    -> -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) is InnerNode Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode ) {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean->:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): leafContaining = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Pair<Rope, Int>( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        Unit
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):InnerNode().iter { child ->
            return leafContaining( child,i)
} = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()(f: (child: Rope) -> Boolean)iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter.:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : TODO() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Rope()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return :( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(fleafContaining (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope{ i: Int): Pair<Rope, Int> = when (rope) ,
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
(child: Rope) -> Boolean InnerNode : Rope() {
    inline fun iter(f: class):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when ((child: Rope) -> Boolean) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: rope):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: }): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
Int
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
{ class Rope
class InnerNode : Rope() sealed
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodethrow IllegalStateException().iter { child ->
            return leafContaining( child,i)
}
()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    leafContaining
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (}) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
rope
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, ,): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( childi: Inti)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode{
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() ()
yM
tailrec fun leafContaining(rope: Rope, :): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode i: Int Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,f: (child: Rope) -> Boolean)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(i):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter TODO
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = { child ->
            return leafContaining( child,i)
}()
}
yM
tailrec fun leafContaining(class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
rope: Rope
yM
tailrec fun leafContaining(rope: Rope, i: (): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOInt)
}
yM
tailrec fun leafContaining(rope: Int, i: Rope): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() Int
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw fun()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline IllegalStateException iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
InnerNode fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is tailrec -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Intf = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(>: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = { (rope) when
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
} InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
is
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode ( Rope() {
    inline fun iter(f: :child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, }: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
i
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
)
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean}:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is Unit -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):InnerNode = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): child: Rope = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (Pair<Rope, Int>) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class :
class InnerNode : Rope() {
    inline fun iter(f: (childRope Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> IllegalStateException
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw {()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, is InnerNode> = when (rope) {
    Int -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: }) -> Boolean):Unit = TODO()
Rope
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (}) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
rope
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContainingIntrope: Rope, i: (): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
TODO fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = tailrec()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope(Rope {
    inline fun iter(f: (child: )) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Ropechild i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { , ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
return fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            tailrec leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    ) -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(is InnerNode
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when ((f: (child: Rope) -> Boolean)) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterrope:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, )> = when (rope) {
    is InnerNode -> {
        InnerNode(Int.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, inline: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    i fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: :)Int Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().child
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (iter { child ->
            return leafContaining( child,i)
}: Rope) -> Boolean):Unit = TODO()
}
yM
) fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO(tailrec
}
yM
fun
sealed class Rope
class InnerNode : Rope() {
    inline tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
} iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
: fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(ftailrec (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Rope> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Int
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is child -> {
        InnerNode().iter { InnerNode ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: f: (child: Rope) -> Boolean): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(Int):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}, Int> = Rope
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) { child ->
            return leafContaining( child,i)
}
    is InnerNode -> {
        InnerNode().iter {
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: rope, i: Int): Pair<Rope, Int> = when (Rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Pair<Rope, Int>, i: Int): Rope = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        Rope
throw IllegalStateException()
    }
}
sealed class InnerNode().iter { child ->
            return leafContaining( child,i)
}
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().fun { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline iter iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
iter fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().tailrec { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode{ child ->
            return leafContaining( child,i)
}).iter (
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: ,): Pair<RopeInt Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Ropef Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(,: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> TODO):Unit = Boolean()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (ropei {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,))
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, =): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit i: Int TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: )): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> BooleanInt:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, Rope: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : i() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter Boolean child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> {):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(TODO()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = )
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope)) {
    inline fun iter(f: (child: Rope( -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: TODO, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Rope()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = { child ->
            return leafContaining( child,i)
} (rope) {
    is InnerNode -> {
        InnerNode().iter when
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> BooleanUnit:) = TODO()
}
yM
tailrec Rope leafContaining(rope: fun, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, Pair: Int): i<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (childTODO Rope) -> Boolean):Unit = :()
}
yM
tailrec fun leafContaining(rope: Rope, }): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
i: Int
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun class(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
leafContaining InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodeIllegalStateException.iter { child ->
            return leafContaining( child,i)
}
throw ()()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( IllegalStateException(),i)
}
throw child
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: ichild: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope{ Int> = when (rope) {
    is InnerNode -> ,
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair:Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode < Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: ), i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,iRope
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> InnerNode when (rope) {
    is = -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
} Rope
class
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,iRope
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : )() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed ) Rope
class InnerNode : Rope(class {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(->, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) rope: Rope Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: {, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() Rope
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
Boolean IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> throw):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is ) -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(InnerNode
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode () {
        InnerNode->.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): i = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,Pair<Rope, Int>)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = -> (rope) {
    is InnerNode -> {
        InnerNode().iter { child when
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    fun
}
sealed class Rope
class InnerNode : Rope() {
    inline } iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(rope: Rope, i: Int)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,())
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOi
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when ()) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope(rope {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode(Rope.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : )() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodeRope.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : ()() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, { child ->
            return leafContaining( child,i)
}> = when (rope) {
    is InnerNode -> {
        InnerNode().iter Int
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int}: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    )
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, Unit: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):i = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (() {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOrope)
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is : -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(fInnerNode (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
Boolean
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> }):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): child = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( Pair<Rope, Int>,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Rope> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Int) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode(){ child ->
            return leafContaining( child,i)
}iter .
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope(rope: Rope, i: Int) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : :() {
    inline fun iter(f: (childRope Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): PairBooleanRope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> <):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> : when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child= Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when Booleanrope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> ():Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) InnerNode().iter { child ->
            return leafContaining( child,i)
}
    is InnerNode -> {
        {
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec child leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( fun,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(InnerNode, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        rope: Rope().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { : ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean)childUnit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, iInnerNode Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        :().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Unit() {
    inline fun iter(f: (child: Rope) -> Boolean):Rope = TODO()
}
yM
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Unit
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):IllegalStateException() = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> TODO
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int)() Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO:
}
yM
tailrec fun leafContaining(rope: Rope, i: throw): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
Int IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContainingRoperope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : (() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
() fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateExceptiontailrec
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, throw): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
i: Int IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun InnerNode(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        leafContaining().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodei.iter { child ->
            return leafContaining( child,())
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is Rope -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: InnerNode) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
: InnerNode : Rope() {
    inline fun iter(fclass (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<{
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() Rope
yM
tailrec fun leafContaining(rope: Rope, {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() i: Int
yM
tailrec fun leafContaining(rope: leafContaining, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Rope( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().) { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(iter
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, {> = when (rope) {
    is InnerNode -> Int
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, child: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (i: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int{: Pair<Rope, Int> = when (rope) {
    is InnerNode -> )
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        Rope().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: InnerNode) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        i().iter { child ->
            return leafContaining( child,InnerNode)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Unit( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):leafContaining = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() Int
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope{ child ->
            return leafContaining( child,i)
} Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter ,
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Intrope: Pair<Rope, Int> = when ()) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() f
    inline fun iter({: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(Rope: Rope, i: Int): Pair<rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode((.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: )child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, )> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(Int
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : :() {
    inline fun iter(fRope (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, InnerNode): Pair<Rope, Int> = when (rope) {
    is i: Int -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode i {
        InnerNode().iter { child ->
            return leafContaining( child,->)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope() i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO,
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,:)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode i Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( Rope,i)
}
throw IllegalStateException()
    }
}
sealed class child
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int)( Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter:f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: rope): Pair<Rope, Int> = when (Int) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: (, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODORope)
}
yM
tailrec fun leafContaining(rope: i, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,Rope)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(f
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(): (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        ()
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOInnerNode().iter { child ->
            return leafContaining( child,i)
}
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, rope> = when (Int) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(child: Rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<child, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (Rope: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw )
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO(IllegalStateException()
}
yM
tailrec fun leafContaining(rope: Rope, i: child): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( Int,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when InnerNode().iter { child ->
            return leafContaining( child,i)
}rope) {
    is InnerNode -> {
        (
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Rope( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : leafContaining() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
sealed class Rope fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
tailrec
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair{
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    } = when (rope) {
    is InnerNode -> <Rope, Int>
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = (TODO)
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<child, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( Rope,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun sealed(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
leafContaining class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Int, i: Int): Pair<Rope, Rope> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        }().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
InnerNode
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): )<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: RopePair -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw child()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (IllegalStateException: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = Boolean (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> when):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { , ->
            return leafContaining( childchildi)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<TODO, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Rope()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): TODO<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Pair()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()iter. { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: TODO) -> Boolean):Unit = Rope()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (f: (child: Rope) -> Boolean) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(rope):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode InnerNode().iter { child ->
            return leafContaining( child,i)
} {
        ->
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().(
throw IllegalStateExceptioniter { child ->
            return leafContaining( child,i)
})
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Rope<Pair, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, :> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode Int Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodechild).iter { child ->
            return leafContaining( (,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw (child: Rope) -> Boolean()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: IllegalStateException):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: ), i: Int): Pair<Rope, Int> = when (ropeRope {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<:, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode Rope Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, IntUnit = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):> = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<(, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: Ropechild: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter )
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO({ child ->
            return leafContaining( child,i)
}
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Intsealed = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
> class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<IllegalStateException, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Rope()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (Unit: Rope) -> Boolean):child = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) iter
    is InnerNode -> {
        InnerNode().{ { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<i, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,Rope)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec () leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOfun
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
Rope
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : }() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair)Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope(< {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()(iter { child ->
            return leafContaining. child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
child class Rope
class InnerNode : Rope() {
    inline fun iter(f: (sealed: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    child -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (is InnerNode: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() InnerNode()
yM
sealed
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
} class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    :
}
sealed class Rope
class InnerNode } Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    :
}
sealed class Rope
class InnerNode is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    } Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope) Int> = when (rope) {
    is InnerNode -> {
        InnerNode(,.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
Rope fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: tailrec) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope-> ) Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Unit, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Rope = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed ( Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODOclass)
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) TODO
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = {()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContainingBoolean
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> ( child,i)):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Rope): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Int) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, (> = when Intrope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( f,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(child: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> )
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope{ -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: ), i: IntRope: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
leafContaining
yM
tailrec fun leafContainingi: Intrope: Rope, (): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    Int
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (ropeiter {
    is InnerNode -> {
        InnerNode().) { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return (( child,i)
}
throw IllegalStateExceptionleafContaining)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) inline
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    { fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
{
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class Unit : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):InnerNode = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when }rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
(
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair{ child ->
            return leafContaining( child,i)
} = when (rope) {
    is InnerNode -> {
        InnerNode().iter <Rope, Int>
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is Rope -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : InnerNode() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<(), Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateExceptionRope
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContainingInnerNode: Pair<Rope, Int> = when (rope) {
    is (rope: Rope, i: Int) -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNodethrow).iter { child ->
            return leafContaining( child,i)
}
( IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<RopeInt ,> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) is
    { InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().Boolean { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> iter):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Boolean<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Pair):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    sealed class Rope -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
is InnerNode
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            :
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean)return leafContaining( child,i)Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, )> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> BooleanInt:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        (().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterInnerNodef: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int( = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: >child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter fun
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline { child ->
            return leafContaining( child,i)
} iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when classrope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed ( Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
)
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope(} {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec i leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,fun)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( Rope,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : child() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> i
        InnerNode().iter { child ->
            return leafContaining( child,{)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: IllegalStateException, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Rope()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, IntRope = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: >) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().sealed class Rope { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
iter
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(ropeRope Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: :) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { Rope ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : child() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: { child ->
            return leafContaining( child,i)
}, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter Rope
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): -> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child Pair<Rope, Int>
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return (
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : RopeleafContaining( child,i)) {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { Rope() ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : child {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is { -> {
        InnerNode().iter InnerNode child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            Rope() leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : return {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int(: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode)).iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun ((f: iterchild: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().TODO
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = iter { child ->
            return leafContaining( child,i)
}()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (child) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( rope,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec TODO() leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = fun
}
yM
tailrec fun leafContaining(rope: Ropei: Int ,): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is IllegalStateException() -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw InnerNode
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = ( (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateExceptionwhen)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> InnerNode().iter { child ->
            return leafContaining( child,i)
} when (rope) {
    is InnerNode -> {
        =
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Unit
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):leafContaining( child,i) = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): (f: (child: Rope) -> Boolean) = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterPair<Rope, Int>:Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is return leafContaining( child,i) -> {
        InnerNode().iter { child ->
            InnerNode
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
inline class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y?
tailrec fun leafContaining(rope: Rope, i: Int): K = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yS
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
    val f = object {
        val a by del()
    }

    f.a
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<AsInt?, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y^
tailrec fun leafContaining(rope: Rope, i: MutableCollection<*>): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Derived() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { "OK" }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: A, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, ULong> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: my, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ˜
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (i) {
            0 -> foo(1)
            else -> null
        }
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
operator class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y9
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Z()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y[
tailrec fun leafContaining(private val s: ByteArray, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y<
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(other: Int):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Long) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (String) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):String = TODO()
}
yL
tailrec fun leafContaining(rope: Int, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÕ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            {
    val c = C(10, 3)
    return if (c.child.toString() == "child13" && c.child.toString() == "child16" && c.child.toString() == "child19") "OK" else "fail"
}
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (list2: Rope) -> Boolean):Unit = TODO()
}
yw
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Map<String, String> by HashMap<String, String>() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is B -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : A() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> String):Unit = TODO()
}
y9
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw x()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (el) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is A.C -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Float() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( 17,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Long( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y-
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {invokeOrder += "1_"; l}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, String> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(B: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : A("C") {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, i: toString): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yS
tailrec fun leafContaining(rope: Rope, i: Int): returnType<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (Pair) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return id(IcLong(42))
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun Outer(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (foo) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class name
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y<
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw this()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is b -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yS
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = intArrayOf()
}
yE
tailrec fun result(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y Ê
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
    return i
}
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, String: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        Int.MAX_VALUE
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is UInt -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is x -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y)
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
        this
    }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): list<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = test()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( p,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( k,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        data().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: String) -> Boolean):Unit = TODO()
}
y;
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return add(0)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is Any? -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<C, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yF
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(var content : String):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { y: Any? ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        0.toByte()
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ö
fun box(): String {
    return C().foo()
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y8
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter((i, _)):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<p2, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        test().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, MaxUL> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Test = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is check1 -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<String> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yF
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return ArrayList<Int>(2)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,s)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y#
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { it == true }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yX
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            {
    return "fail1: global = $global"
  }
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<String, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y=
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (T) -> R):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw array2()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):list2 = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Boolean = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO(msg)
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : a() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y<
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return f(null)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yT
tailrec fun leafContaining(rope: Rope, val s: String): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Nothing): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Double) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: x): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : test() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):stack = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<x, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (UInt: Rope) -> Boolean):Unit = TODO()
}
ya
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode(1, "Jeff", "Bridges").iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y=
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Outer()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, UInt> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(val param: String = "OK"):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class String
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y.
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
        ok = "OK"
    }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Delegate()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):e = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : m() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ë
override fun foo(t: String) = "Z"
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Retention, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y9
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            {
        }
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(s: S, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: v) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( string,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().Double { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y6
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(s: S):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        C().foo(42, 'O')
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { val y: String ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class B : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):add = TODO()
}
y<
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw test()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,b = 2)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Int() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
            foo("O")
            foo(foo, 1)
        }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
annotation class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y@
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return x( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (Boolean) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: String): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Outer, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: T) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<a, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
        test("ok")
        test("ok", 200)
    }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { () ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> box):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        String().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): BooleanArray<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(Short: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = i()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        B1("q").iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw String()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yA
tailrec fun leafContaining(rope: Rope, i: Int): Int = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Byte) -> Boolean):Unit = TODO()
}
y2
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter():Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        i.toString()
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        DOUBLE_RANGE().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw toLong()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y8
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: Int):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (step: Rope) -> Boolean):Unit = TODO()
}
y$
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { it == false }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is closure1 -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        r().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):i = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Int):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = p()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
open inner class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        B().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Foo() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: hashCode, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y@
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return i( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y`
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : HashMap<String, Double>() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining("OK")
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Name() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { value: String ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yT
tailrec fun leafContaining(rope: Rope, i: Int): objectArray<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y^
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (TValue) -> Parser<TInput, TIntermediate>):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( 0.0,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):f = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw downTo()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: () -> Boolean):Unit = TODO()
}
y9
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return "OK"
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw AssertionError("Fail set")
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is Array<out T>? -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: j) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (y) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is () -> String -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (b) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : box() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: foo, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { add ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: () -> Int):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( A,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Any?):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class C : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):array = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, A: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: box) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Int = TODO()
}
yn
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
interface R<T: Comparable<T>> {
    var value: T
}
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { i ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        X.B.value
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: foo) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> UInt):Unit = TODO()
}
yJ
tailrec fun leafContaining(a: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(l, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yW
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode("Blow up!").iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : list4() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yV
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : ContainerImpl() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is U -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { (s: Any) ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ⁄
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> "OK"
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw Exception(msg)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (res) {
                              is Result.ParseError -> Result.ParseError(res.productionLabel, res.child, res.rest)
                              is Result.Value -> {
                                  val v = res.value
                                  val res2 = selector(v)(res.rest)
                                  when (res2) {
                                      is Result.ParseError -> Result.ParseError(res2.productionLabel, res2.child, res2.rest)
                                      is Result.Value -> Result.Value(projector(v, res2.value), res2.rest)
                                  }
                              }
                          }
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Array):Unit = TODO()
}
yf
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : ClassWithToString(), ISomething {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yû
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            {
    val b = Box<Long>(-1)
    val expected: Long? = -1L
    return if (b.value == expected) "OK" else "fail"
}
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<A, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Int, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): test8<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is f -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y\
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { val fn: () -> String ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = Base()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Derived()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().setValue { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Float( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = add(i)
}
yU
tailrec fun leafContaining(rope: KProperty<*>, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw UnsupportedOperationException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): i<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { this }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y3
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(i):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: String, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is String -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = String()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<*> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : String() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
ya
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    public override val size: Int get() = storage.size

    override operator fun iterator() = TODO()
    override fun contains(element: MyUInt): Boolean = storage.contains(element.x)
    override fun containsAll(elements: Collection<MyUInt>): Boolean = elements.all { storage.contains(it.x) }
    override fun isEmpty(): Boolean = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
const class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(newValue: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,"OK")
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class size : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (i) -> Boolean):Unit = TODO()
}
y;
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(a: Float?):Unit = TODO()
}
yÄ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
class Outer {
    val s = "OK"

    inner class Inner : Foo({ s })
}
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( 2,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(s: String): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yã
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            {
    if (!equals1(-0.0F, 0.0F)) return "fail 1"
    if (!equals2(-0.0F, 0.0F)) return "fail 2"
    if (!equals3(-0.0F, 0.0F)) return "fail 3"
    if (!equals4(-0.0F, 0.0F)) return "fail 4"

    // Smart casts behavior in 1.2
    if (equals5(-0.0F, 0.0F)) return "fail 5"
    if (equals6(-0.0F, 0.0F)) return "fail 6"

    if (!equals7(-0.0F, 0.0F)) return "fail 7"

    // Smart casts behavior in 1.2
    if (equals8(-0.0F, 0.0F)) return "fail 8"

    if (!equals8(null, null)) return "fail 9"
    if (equals8(null, 0.0F)) return "fail 10"
    if (equals8(0.0F, null)) return "fail 11"

    return "OK"
}
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y?
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return { prop }()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): baz<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(box: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<UInt> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): list2<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: a) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { hasNext ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y(
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { (x, y) -> x + y }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Long, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { (x: T) ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yT
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( (MinUL + 2u),i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        ONE(42).iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yY
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class FunDependencyEdgeImpl : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return InnerSubclass().testInner()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, x: Any): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yX
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,x.toString())
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return set( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : PublishedApi() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yÎ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
inline class DelegateStr(val ignored: String) {

    operator fun getValue(thisRef: Any?, prop: Any?) =
        backing

    operator fun setValue(thisRef: Any?, prop: Any?, newValue: Int) {
        setterInvoked++
        backing = newValue
    }
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    fun box(): String {
    val outer1 = Outer("propValue1")
    val a1 = outer1.A2("abc")
    if (a1.parentProp != "abc#propValue1#propValue1") return "fail1: ${a1.parentProp}"
    if (a1.prop != "abc#propValue1") return "fail2: ${a1.prop}"
    if (outer1.sideEffects != "propValue1#first#third#second#propValue1#fifth#seventh#sixth") return "fail1-sideEffects: ${outer1.sideEffects}"

    val outer2 = Outer("propValue2")
    val a2 = outer2.A2(123)
    if (a2.parentProp != "124#propValue2#propValue2#int") return "fail3: ${a2.parentProp}"
    if (a2.prop != "123#propValue2#int") return "fail4: ${a2.prop}"
    if (outer2.sideEffects != "propValue2#first#third#second#fourth#propValue2#fifth#seventh#eighth") return "fail2-sideEffects: ${outer2.sideEffects}"

    return "OK"
}
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):result = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,r)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
abstract class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: oldValue, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
fun box() : String {
    val s = "notA"
    val id = when (s) {
        "a" -> 1
        else -> null
    }

    if (id == null) return "OK"
    return "fail"
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y=
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw count()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { val p: Int ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yq
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { x: () -> Boolean = { super.equals(this) } ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class ArrayList : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            println(it.asList())
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yc
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {
        object {
            fun run() = prop + test()
        }.run()
    }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y;
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw bar()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: x) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( true,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        list2.add(i)
        if (list2.size > 23) break
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, t: Any?): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun String(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        reversed().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y=
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return "fail 2"
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (id) {
        0 -> "OK"
        else -> throw Exception("unsupported $id")
    }
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(C: (child: Rope) -> Boolean):Unit = TODO()
}
y Ã
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    2 -> 6
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return withIndex( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y@
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (T) -> Unit):Unit = TODO()
}
yT
tailrec fun leafContaining(rope: Rope, iterable: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Outer() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y—
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
enum class X {
    B {
        val value2 = "K"
        override val value = "O".letNoInline { it + value2 }
    };

    abstract val value: String
}
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yR
tailrec fun leafContaining(rope: Rope, Double: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return next( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y:
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw b(1)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yU
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(CapturesX: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): A<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y˛
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    fun box(): String {
    val list1 = ArrayList<Int>()
    val range1 = (5 downTo 3).reversed()
    for (i in range1) {
        list1.add(i)
        if (list1.size > 23) break
    }
    if (list1 != listOf<Int>(3, 4, 5)) {
        return "Wrong elements for (5 downTo 3).reversed(): $list1"
    }

    val list2 = ArrayList<Int>()
    val range2 = (5.toByte() downTo 3.toByte()).reversed()
    for (i in range2) {
        list2.add(i)
        if (list2.size > 23) break
    }
    if (list2 != listOf<Int>(3, 4, 5)) {
        return "Wrong elements for (5.toByte() downTo 3.toByte()).reversed(): $list2"
    }

    val list3 = ArrayList<Int>()
    val range3 = (5.toShort() downTo 3.toShort()).reversed()
    for (i in range3) {
        list3.add(i)
        if (list3.size > 23) break
    }
    if (list3 != listOf<Int>(3, 4, 5)) {
        return "Wrong elements for (5.toShort() downTo 3.toShort()).reversed(): $list3"
    }

    val list4 = ArrayList<Long>()
    val range4 = (5L downTo 3L).reversed()
    for (i in range4) {
        list4.add(i)
        if (list4.size > 23) break
    }
    if (list4 != listOf<Long>(3, 4, 5)) {
        return "Wrong elements for (5L downTo 3L).reversed(): $list4"
    }

    val list5 = ArrayList<Char>()
    val range5 = ('c' downTo 'a').reversed()
    for (i in range5) {
        list5.add(i)
        if (list5.size > 23) break
    }
    if (list5 != listOf<Char>('a', 'b', 'c')) {
        return "Wrong elements for ('c' downTo 'a').reversed(): $list5"
    }

    return "OK"
}
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (t: F.A) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        T().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> lazy):Unit = TODO()
}
yF
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        r2().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining()
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
    val a = A()
    a.setMyStr()
    return a.getMyStr()
}
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( super,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        component1().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i : Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( String,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = A()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is A -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( B2,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class plusZero
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        IcLong(42).iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> MyString):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: B, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yT
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(iterator: (child: Rope) -> Boolean):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw toByte()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yQ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        Value("O", "K").iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yE
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is T -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return Int( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : x() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yN
tailrec fun leafContaining(rope: MaxUI, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(xs: Iterator<Int>): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y*
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { this[i] = this[j] }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y;
tailrec fun leafContaining(): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().x { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yO
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,0.0)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yP
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class isCheck
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y'
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { x(1) in list() }
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun testCoalesce(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : y() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
}
        InnerNode().iter { child ->
            return leafContaining( child,i)
    is InnerNode -> {
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yM
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
throw IllegalStateException()
            return leafContaining( child,i)
}
        InnerNode().iter { child ->
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class 
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) 
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }

sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: , i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
     fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is  -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: ) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): <Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : () {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> 
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when () {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    isInnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ÷
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> 
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yF
 fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode :  {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y5
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return 
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {  ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope){
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y?
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return ( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int>= when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y Ú
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope

yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter {child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i:Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ∆
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> =  (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException(
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class  : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, > = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO
}
yL
tailrec fun leafContaining(rope: Rope, : Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean): = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode  Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( ,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child 
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, ): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode(). { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed  Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit= TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean:Unit = TODO()
}
yI
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun (f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode(.iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int):Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yJ
tailrec fun leafContaining(rope: Rope, i: ): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline funiter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode-> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
 class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y>
tailrec fun leafContaining(rope: Rope, i: Int):  = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Ropeclass InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContainingrope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) ->Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inlinefun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope) {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        ().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode :Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope,Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
classInnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode()iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope)  Boolean):Unit = TODO()
}
y5
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: ):Unit = TODO()
}
y6
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw 
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yF
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> ):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()}
yL
tailrec fun leafContaining(rope: Rope,i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y<
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}

class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)

throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope)-> Boolean):Unit = TODO()
}
yB
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        .iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y.
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int) Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            returnleafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode: Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealedclass Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yC
tailrec fun leafContaining(, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
 IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y ≤
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = 
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
             leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> =when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child:Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when(rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode ->{
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y0
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter:Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO(
}
y@
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f:  -> Boolean):Unit = TODO()
}
y
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter 
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yA
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
     -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode  {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrecfun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit  TODO()
}
y8
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw ()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO)
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iterf: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec funleafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yK
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
     InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit =TODO()
}
y9
tailrec fun leafContaining: Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope( {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed classRope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yG
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = 
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()

yH
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
 InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException)
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): PairRope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope(){
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
y?
tailrec fun (rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean)Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f:(child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter  child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yD
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {InnerNode().iter { child ->
            return leafContaining( child,i)
}
throw IllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
yL
tailrec fun leafContaining(rope: Rope, i: Int): Pair<Rope, Int> = when (rope) {
    is InnerNode -> {
        InnerNode().iter { child ->
            return leafContaining( child,i)
}
throwIllegalStateException()
    }
}
sealed class Rope
class InnerNode : Rope() {
    inline fun iter(f: (child: Rope) -> Boolean):Unit = TODO()
}
ˇˇ