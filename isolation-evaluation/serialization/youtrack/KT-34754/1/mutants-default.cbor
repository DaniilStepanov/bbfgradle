øiexportTaggdefaultnoriginalSampleyT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
gmutantsüyÆ// Original bug: KT-36100
// Duplicated bug: KT-34754


val v = false
if (v) {data class Tree(val value: Int, val children: List<Tree>)} else {data class Tree(val value: Int, val children: List<Tree>)}


fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)


val j = false
if (j) {fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}} else {fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}}

yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree
val c = false
try
{(val value: Int, val children: List<Tree>)}
catch(e: Exception){}
finally{}


fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y@// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = 
val j = false
when (j) {
 true -> {sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}}
 else -> {sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}}
}

y|// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = 
val d = true
if (d) {sequence} else {sequence}
 {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yÉ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(
val h = false
if (h) {val value: Int} else {val value: Int}
, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yå// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, 
val a = true
if (a) {val children: List<Tree>} else {val children: List<Tree>}
)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun 
val x = true
try
{Tree}
catch(e: Exception){}
finally{}
.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): 
val k = false
try
{Sequence}
catch(e: Exception){}
finally{}
<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y#// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence 
val z = true
if (z) {{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}} else {{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}}

y#// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence 
val y = true
if (y) {{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}} else {{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}}

yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    
val r = true
try
{suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)}
catch(e: Exception){}
finally{}

}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: 
val y = false
try
{Int}
catch(e: Exception){}
finally{}
, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yå// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: 
val v = false
when (v) {
 true -> {List}
 else -> {List}
}
<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y˙// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    
val g = true
if (g) {suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }} else {suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }}

    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    
val o = false
try
{linearize(this@asLinearized)}
catch(e: Exception){}
finally{}

}
yw// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<
val n = true
if (n) {Int} else {Int}
> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) 
val f = true
try
{{
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }}
catch(e: Exception){}
finally{}

    linearize(this@asLinearized)
}
yê// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    
val i = true
when (i) {
 true -> {linearize}
 else -> {linearize}
}
(this@asLinearized)
}
y~// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(
val r = true
if (r) {tree: Tree} else {tree: Tree}
) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yÜ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        
val f = false
if (f) {yield(tree.value)} else {yield(tree.value)}

        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        
val k = true
try
{tree.children.forEach { linearize(it) }}
catch(e: Exception){}
finally{}

    }
    linearize(this@asLinearized)
}
yî// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun 
val s = true
when (s) {
 true -> {SequenceScope}
 else -> {SequenceScope}
}
<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        
val z = false
try
{yield}
catch(e: Exception){}
finally{}
(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yÇ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        
val c = false
if (c) {tree.children} else {tree.children}
.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.
val j = false
try
{forEach { linearize(it) }}
catch(e: Exception){}
finally{}

    }
    linearize(this@asLinearized)
}
yò// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(
val b = true
when (b) {
 true -> {this@asLinearized}
 else -> {this@asLinearized}
}
)
}
yå// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<
val v = false
when (v) {
 true -> {Tree}
 else -> {Tree}
}
>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        
val o = false
try
{tree}
catch(e: Exception){}
finally{}
.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yê// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.
val s = false
when (s) {
 true -> {children}
 else -> {children}
}
.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.
val i = true
try
{forEach}
catch(e: Exception){}
finally{}
 { linearize(it) }
    }
    linearize(this@asLinearized)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(
val c = true
try
{this}
catch(e: Exception){}
finally{}
@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: 
val e = false
try
{Tree}
catch(e: Exception){}
finally{}
) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yí// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(
val e = false
when (e) {
 true -> {tree.value}
 else -> {tree.value}
}
)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yÖ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach 
val v = true
if (v) {{ linearize(it) }} else {{ linearize(it) }}

    }
    linearize(this@asLinearized)
}
yÇ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this
val i = false
if (i) {@asLinearized} else {@asLinearized}
)
}
yâ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(
val x = true
try
{tree}
catch(e: Exception){}
finally{}
.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yç// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.
val y = false
when (y) {
 true -> {value}
 else -> {value}
}
)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yä// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach 
val m = false
try
{{ linearize(it) }}
catch(e: Exception){}
finally{}

    }
    linearize(this@asLinearized)
}
yw// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<
val j = true
if (j) {Int} else {Int}
>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yï// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { 
val t = false
when (t) {
 true -> {linearize(it)}
 else -> {linearize(it)}
}
 }
    }
    linearize(this@asLinearized)
}
yî// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { 
val b = true
when (b) {
 true -> {linearize(it)}
 else -> {linearize(it)}
}
 }
    }
    linearize(this@asLinearized)
}
yê// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { 
val i = true
when (i) {
 true -> {linearize}
 else -> {linearize}
}
(it) }
    }
    linearize(this@asLinearized)
}
yv// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(
val e = true
if (e) {it} else {it}
) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = (sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
})
y µ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    (suspend
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield((tree.value))
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List!!<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int!!> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }!!
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this!!@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it)!! }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun (Tree)?.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): (Sequence<Int>)? = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: (Int)?, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: (List<Tree>)?)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<(Int)?> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun (SequenceScope<Int>)?.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<(Tree)?>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: (Tree)?) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<(Int)?>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>!!.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children!!.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree!!.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.valueforEach { linearize(it) }
        tree.children.)
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.valueit
        tree.children.forEach { linearize()) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List})

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) <Tree>
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Treetree)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(>.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: tree)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(List<Tree>.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized))

fun Tree.asLinearized(): Sequence<Int> = sequence {
    List<Tree>
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScopeforEach { linearize(it) }.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.<Int>
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<linearize>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Tree(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<TreeInt)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<>>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.{ linearize(it) }.forEach children
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun .<Int>.linearize(tree: Tree) {
        yield(treeSequenceScopevalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearizedasLinearized: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@())
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Tree<List>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun ).asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearizedTree
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: tree.value) {
        yield(Tree)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<yield(tree.value)>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Tree
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Sequence.asLinearized(): Tree<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val Tree: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: children) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun linearize<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { SequenceScope(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree<Int>)

fun Tree.asLinearized(): Sequence> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> ) sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value=
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

Tree class Tree(val value: Int, val children: List<Tree>)

fun data.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} = sequence <Int>
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()Tree Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: :) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldthistree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize((@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Treesequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}

fun Tree.asLinearized(): Sequence<Int> = (val value: Int, val children: List<Tree>)
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children() List<Tree>)

fun Tree.asLinearized:: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class TreeIntval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<(> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    asLinearized
    linearize(this@suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    })
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()this Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(:@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<linearize>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Int(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<it>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(Int) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(tree.value value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(val)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class >(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<IntTree.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} = sequence Sequence<Int>
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(Tree value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: val) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: IntTree val children: List<Tree>)

fun ,.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): @asLinearized = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisSequence<Int>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

() class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearizeddata: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun Tree<Int>.linearize(tree: SequenceScope) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.))
        tree.children.forEach { linearize(itvalue }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Intthis@asLinearized.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        linearize.children.forEach { linearize(it) }
    }
    tree(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class (it)(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearizeTree }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence class
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.@asLinearized)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisvalue)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Listlinearize)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { <Tree>(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) )
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized{
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.<(): SequenceasLinearizedInt> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = yield {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        sequence(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    @ fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thissuspendasLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<}> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
Int
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: (this@asLinearized)<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearizeList
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree({ linearize(it) }, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach val value: Int
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val, val value: Int children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

linearize class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { data(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

( class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearizeddata): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it(val value: Int, val children: List<Tree>) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<IntTree = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: >) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, asLinearized)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@val children: List<Tree>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value> Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int:.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun (.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearizeSequenceScope<Int>this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> this sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(=@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): . = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.childrenSequence<Int>forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.valuelinearize
        tree.children.forEach { linearize(it) }
    }
    )(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): yield(tree.value) = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Sequence<Int>
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

SequenceScope<Int>

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun data class Tree(val value: Int, val children: List<Tree>).linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(Tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

tree.children.forEach { linearize(it) } class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        data
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<children> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.Int.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize}
(this@asLinearized)
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.childrenlinearizeforEach { linearize(it) }
    }
    .(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val valuechildren Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.:.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Treechildren {
        yield(tree.value)
        tree.).forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}> = sequence Int
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val (: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizevaluetree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int) val children: List<Tree>,

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}, val children: List<Tree>)

Int
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

(tree.value)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yielddata class Tree(val value: Int, val children: List<Tree>)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val {: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach value linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: children) {
        yield(tree.value)
        tree.Tree.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, yield children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        val(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(yield(tree.value): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        )
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value( Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield:tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun linearize.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    SequenceScope<Int>(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()Sequence :<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    } class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    data
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        .(tree.value)
        tree.childrenyieldforEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>tree: Treelinearize(.) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<value>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.Tree)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Intsuspend val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    , fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence :
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class (Treeval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree((, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldval value: Inttree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}.asLinearized(): Sequence<Int> = sequence Tree
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun it.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(Tree) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Intyield val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        ,(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun (.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldTreetree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.tree(tree: Tree) {
        yield(linearize.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: forEach, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.Int { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: {, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach Int linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>this@asLinearizedlinearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(.)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Sequence, val children: List<Tree>)

fun Tree.asLinearized(): Int<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.this(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(asLinearized@asLinearized)
}
yT)
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree// Original bug: KT-36100 {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: tree, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(Int: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class TreeIntval value: (, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    Tree
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend Tree SequenceScope<Int>.linearize(tree: fun) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<{
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) Tree
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
(this@asLinearized)

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize// Duplicated bug: KT-34754
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<linearize(it)>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Int }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Listtree.childrenTree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        <.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: asLinearized) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@Tree)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

SequenceScope class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun data<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<)> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: TreeInt {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<this@asLinearized> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(Int)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val tree: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        children.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: linearize(it))

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { List<Tree> }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: .) {
        yield(treeTreevalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.this(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(linearize@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(this: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize()@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized({ linearize(it) }: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach )
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}>)

fun Tree.asLinearized(): Sequence<Int> = sequence Tree
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    } fun SequenceScope<Int>.linearize(tree: Tree) suspend
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.it(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(linearize) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List(it)Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize< }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<)>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(itTree }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(). Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children:forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        treeasLinearizedchildren.forEach { linearize(it) }
    }
    linearize(this@.)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, Tree)

fun val children: List<Tree>.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()Int Sequence<Int> = sequence {
    suspend fun SequenceScope<:>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val SequenceScope<Int>: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun value.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value> Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int: = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun tree.linearize(SequenceScope<Int>: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence children
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized<Int>: Sequence<Int> = sequence {
    suspend fun SequenceScope().linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: @asLinearized)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisList<Tree>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: {<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach List linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

Sequence class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): data<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: this@asLinearized) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(Tree)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { this@asLinearized }
    }
    linearize(linearize(it))
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(it: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize()) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): linearize<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Sequence(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    @asLinearized fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thissuspend)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): SequencetreeInt> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(<.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(children value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.val.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence yield(tree.value)
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        {
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<yield> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Int(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.{(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach asLinearized linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<linearize> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Int(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val SequenceScope: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun children<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): SequenceTreeInt> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: <) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence@Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this<asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: tree<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(List.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence@asLinearized = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this<Int>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<(tree.value)>.linearize(tree: Tree) {
        yieldInt
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: <Tree>List)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        linearize(it).children.forEach { tree }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun linearize(it).linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { SequenceScope<Int> }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun tree.children.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Tree.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: linearize, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Int(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

( class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizedatatree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): tree<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Sequence.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>Tree

fun ).asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.it.forEach { linearize(children) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearizedTree: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: ()) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

<Int> Tree.asLinearized(): Sequencefun = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: yield, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Int(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val }: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
children
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int{ linearize(it) } val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach ,
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}>)

Tree
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}<Int> = sequence Sequence
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(this) }
    }
    linearize(it@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: ), val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(itInt }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val tree: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        value.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree@asLinearizedval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this()
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): forEach = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.Sequence<Int> { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: <Tree>, val children: ListInt)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun linearize.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.Tree(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: List<Tree>, val children: Int)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun (.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearizeTreeit) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value} Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    :
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun tree.children.forEach { linearize(it) }<Int>.linearize(tree: Tree) {
        yield(tree.value)
        SequenceScope
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence List
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List{
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) <
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend (tree.value) SequenceScope<Int>.linearize(tree: Tree) {
        yieldfun
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(Int: Sequence<)> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree:val value: Int, val children: List<Tree>)

fun Tree.asLinearized()( Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val childrenInt List<Tree>)

fun Tree.asLinearized(): Sequence<:> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>@asLinearizedlinearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this.)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Int = sequence {
    suspend fun SequenceScope<Sequence<Int>>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Int<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<List>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<tree> = sequence {
    suspend fun SequenceScope<Int>.linearize(Int: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = suspend {
    sequence fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<.>.linearize(tree: Tree) {
        yield(treeIntvalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

val children: List<Tree> class Tree(val value: Int, data)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend . SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.childrenfunforEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(it.value)
        tree.children.forEach { linearize(tree) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        .treechildren.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.this@asLinearized { linearize(it) }
    }
    linearize(forEach)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val <: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScopevalueInt>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): yield<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Sequence(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<{
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }>.linearize(tree: Tree) Int
    linearize(this@asLinearized)
}
yTclass
// Duplicated bug: KT-34754

data // Original bug: KT-36100 Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun ..asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(treeTreevalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        ..childrentreeforEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.}
    forEach { linearize(it) }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val Sequence: List<Tree>)

fun Tree.asLinearized(): children<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, tree)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        val children: List<Tree>.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: tree.children.forEach { linearize(it) }, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Int
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach @asLinearized linearize(it) }
    }
    linearize(this{)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} sequence
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val yield: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        children(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<@>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisIntasLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: forEach<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.List { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun >.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<IntTree.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { ((it) }
    }
    linearizelinearizethis@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = val value: Int
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>SequenceScope<Int>

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun ).linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        }.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
tree.children
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

linearize class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    data(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Inttree.value val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(,)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Tree, val children: List<Int>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        (yieldtree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}: Int, val children: List<Tree>)

value
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope)Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized<
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree.children) {
        yield(tree.value)
        tree: Tree.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequencesuspend = sequence {
    <Int> fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.( { linearize(it) }
    }
    linearizeforEachthis@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int>Int> = sequence {
    suspend fun SequenceScope<.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<forEach> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.Int { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

tree: Tree

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(data class Tree(val value: Int, val children: List<Tree>)) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data < Tree(val value: Int, val children: ListclassTree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence value
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<suspend> = sequence {
    Int fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Sequence>)

fun Tree.asLinearized(): Tree<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val SequenceScope: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun value<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int. = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children>forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): . = sequence {
    suspend fun SequenceScope<Int>Sequence<Int>linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class TreeIntval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<(>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun =.asLinearized(): Sequence<Int> Tree sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(@asLinearized) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thistree: Tree)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        linearize
        tree.children.forEach { linearize(it) }
    }
    yield(tree.value)(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { @asLinearized(it) }
    }
    linearize(thislinearize)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

tree.value

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(data class Tree(val value: Int, val children: List<Tree>))
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Intlinearize = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    >(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: ListSequenceScope<Int>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun <Tree>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

) class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearizeddata
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizechildren {
        yield(tree.value)
        tree.(tree: Tree).forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.yield(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        asLinearized(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: ListSequence)

fun Tree.asLinearized(): <Tree><Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(tree value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(val.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List:Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree< Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<=> Int sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<val value: Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun (tree.value).asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldTree
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
>

data class Tree(val value: Int, val children: List<Tree// Duplicated bug: KT-34754)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: asLinearized)

fun Tree.List<Tree>(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequencetree = sequence {
    suspend fun SequenceScope<Int>.linearize(<Int>: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<asLinearized>)

fun Tree.Tree(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { @asLinearized }
    }
    linearize(thislinearize(it))
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence ,
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.forEach(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.asLinearized { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun .TreeasLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: :, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(treeInt Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): it<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(Sequence) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Treevalue)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.>)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(@asLinearized) }
    }
    linearize(thisit)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class TreeTreeval value: Int, val children: List<(>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun }.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    Tree
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

val value: Int class Tree(data, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List))

fun Tree.asLinearized(<Tree>: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}): Sequence<Int> = sequence (
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: <Int><Tree>)

fun Tree.asLinearized(): SequenceList = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Treesequenceval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = ( {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<(this@asLinearized)>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearizeTree
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<tree.value>.linearize(tree: Tree) {
        yield(Int)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun children<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.SequenceScope.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: (tree.value), val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldInt
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Inttree val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        ,.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence Int
    suspend fun SequenceScope<{>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val {: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) children
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

Sequence<Int> Tree.asLinearized(): fun = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<.> = sequence {
    suspend fun SequenceScope<Int>Intlinearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<)> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.valueInt
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()yield Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        :(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

forEach class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.data { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: value, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.Int)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = val
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizetree {
        yield((tree: Tree).value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): tree: Tree = sequence {
    suspend fun SequenceScope<Int>.linearize(Sequence<Int>) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope{ linearize(it) }.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach <Int>
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    this@asLinearized(linearize)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Tree> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Int) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> Int sequence {
    suspend fun SequenceScope<=>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        (.children.forEach { linearizetreeit) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, forEach children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.val { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.linearize { forEach(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree( Tree) {
        yield:tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<asLinearized>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@Int)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

<Int> class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequencedata = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Treesuspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }asLinearized(): Sequence<Int> = sequence {
    .
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<sequence>)

fun Tree.asLinearized(): Sequence<Int> = Tree {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScopeTree.linearize(tree: <Int>) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Inttree.value = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(>)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> SequenceScope sequence {
    suspend fun =<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()@ Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this:asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Int.asLinearized(): Sequence<Tree> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value( Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize:it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Tree, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Int) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

. class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(treedatavalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val valueasLinearized Int, val children: List<Tree>)

fun Tree.:(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = children
yT// Original bug: KT-36100
this@asLinearized

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(// Duplicated bug: KT-34754)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.it { linearize(forEach) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: >, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<IntInt = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): value = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.Sequence<Int>)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence Int
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun tree.children.forEach { linearize(it) }.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Tree
    }
    linearize(this@asLinearized)
}
yT{ linearize(it) }
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach // Original bug: KT-36100
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<(>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldTreetree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(}) }
    }
    linearize(this@asLinearized)
it
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val Tree: Int, val children: List<value>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
} =
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Tree<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Sequence) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<it> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(Int) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: (this@asLinearized))

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearizeList<Tree>
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: val children: List<Tree>, Int)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Sequence<Int>>)

fun Tree.asLinearized(): Tree = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun this@asLinearized.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(SequenceScope<Int>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizetreetree: Tree) {
        yield((.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(treeyield(tree.value) Tree) {
        :
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): ) = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: TreeSequence<Int> {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val valuelinearize Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { :(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children( List<Tree>)

fun Tree.asLinearized:): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<IntasLinearized = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@>)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.forEach(tree: Tree) {
        yield(tree.value)
        tree.children.linearize { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun TreetreeasLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        ..children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val childrenTree List<Tree>)

fun :.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): > = sequence {
    suspend fun SequenceScope<IntSequence<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun this.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(Tree@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

sequence

fun Tree.asLinearized(): Sequence<Int> = data class Tree(val value: Int, val children: List<Tree>) {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<linearize(this@asLinearized)>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Int
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Listfun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
})

<Tree>
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<<Int>>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScopeTree.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun }.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
Tree
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): tree = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Sequence<Int>.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List{)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach <Tree> linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): }<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
Sequence
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun }.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) Tree
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): sequence = Sequence<Int> {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<this> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(Int@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<linearize> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Int(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized()( Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize:it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int{.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach > linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Int.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Tree>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }<Int> = sequence {
    Sequence
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<it>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(Tree) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield({ linearize(it) }.value)
        tree.children.forEach tree
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: suspend<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    List fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: linearize<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    List(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.}(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) linearize
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun ).asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.valueTree
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, { linearize(it) } children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach val
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend linearize(this@asLinearized) SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    fun
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(treeforEach Tree) {
        yield(tree.value)
        tree.children.: { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = SequenceScope<Int> {
    suspend fun sequence.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<this>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(Tree@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data Int Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<class>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        )(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearizedyield
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        forEach.children.tree { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, linearize children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    val(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class List<Tree>(val value: Int, val children: Tree)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data ) Tree(val value: Int, val children: List<Tree>class

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        linearize(it)
        tree.children.forEach { yield(tree.value) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<{> = sequence Int
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearizeit() }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<T>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(contains.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.x)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y?// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    code(s)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = String {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun x<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ∞// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { it("K") }
y]// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        StringBuilder.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y:// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        list.add("0")
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@id)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): String = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(a: UInt?) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun R.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    O(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { toInt() }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): bar<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.a)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yD// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(1)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: String) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    value(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { fn(it) }
    }
    linearize(this@asLinearized)
}
y ∂// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {x -> x.toLong()}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@Foo)
}
yZ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: (String) -> Unit)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    open fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.Int.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Any?>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<String>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y,// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree()

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(x) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun String.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yo// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(UnsupportedOperationException) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@loop)
}
yC// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize()
}
y¡// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {
        val x = object {
            init {
                38["Hello!"] = "OK"
            }
        }
        result
    }
    }
    linearize(this@asLinearized)
}
y;// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    f()
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    test2(this@asLinearized)
}
y[// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(val data : String) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { i(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Int>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: IntRange<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ü// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = C()
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val d: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(u.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<*> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@a)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(A@asLinearized)
}
y4// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    fun box(): String {
    var a : Shape? = Shape("fail");
    a?.result = "OK";

    return a!!.result
}
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        a.foo().forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y¡// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(b = {invokeOrder += "1_"; l}(), c = {invokeOrder += "${captured}"; "${captured}"}, a = {invokeOrder+="0_"; i}()) }
    }
    linearize(this@asLinearized)
}
y†// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { {
    val div = u / ua
    if (div != ub) throw AssertionError("$div")

    return "OK"
} }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree((a, b), val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Test().z.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.a { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.MINUS0D { linearize(it) }
    }
    linearize(this@asLinearized)
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val i : Int)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yY// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        KProperty.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun String.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize("239") }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { dense(it) }
    }
    linearize(this@asLinearized)
}
y ∫// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { this[i] = this[j] }
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        f(null)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize() {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    String(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<AsAny>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ≠// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { "OK" }
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: A, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: C) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): String<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Short) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(x.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<*>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.b(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { String(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val z1a: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y4// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val x: T)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.z { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisa@)
}
y[// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.Delegate { ICOverIC(ICLong(0)) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: R) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ´// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { -1 }
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun T.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: T) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y §// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = plus(10)
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<range1>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y^// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun useNullableStr.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.toInt { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val result: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: String, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yY// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<getSecond>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: String)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.size.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.Array(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        f(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: add<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Bar<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@B)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val String: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(Int.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(0.0F)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val c: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Int.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        run.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = v2 {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun toUByte.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = test {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yE// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun Int.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.box { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(equals.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<OHolder>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y{// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(object : Base2, Base by Delegate() {
    }.test())
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Interface = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(log.toString())
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.i(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun L.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@foo)
}
yt// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun checkLess(x: Boolean, y: Boolean) = when {
    x >= y    -> "Fail $x >= $y"
    !(x < y)  -> "Fail !($x < $y)"
    !(x <= y) -> "Fail !($x <= $y)"
    x > y     -> "Fail $x > $y"
    x.compareTo(y) >= 0 -> "Fail $x.compareTo($y) >= 0"
    else -> "OK"
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize((a, b)) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: A<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Foo<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.Comparator(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { C("a", 42u) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.String { linearize(it) }
    }
    linearize(this@asLinearized)
}
y †// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = B(o)
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { foo(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.prop3.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yF// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        f()
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: zero) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ±// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { x = "OK" }
y Ê// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
    fun bar(y: String) = this + y
    return bar("K")
}
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { 1 }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Z, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y7// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        B().foo(1)
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Password<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y0// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        t.x
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        u(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.Unit(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Test.ok.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): i<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Z() }
    }
    linearize(this@asLinearized)
}
y9// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val x: String)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y@// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val fn: () -> String)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(a: Int = 1) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@testFun4)
}
y‹// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { {
  if (global != 0) {
    return "fail1: global = $global"
  }

  val c = C()
  if (global == 1) return "OK" else return "fail2: global = $global"
} }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    private fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thislabel@)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun Foo<T>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        b2.set(4, 5).forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Int) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { it }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.A { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(i) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { "" }
    }
    linearize(this@asLinearized)
}
y ∫// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { it.key + it.value }
y •// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun box(): String {
    A.foo()
    return state
}
y ¶// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = reversed()
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: UInt<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.String.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y\// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<arrayOfNulls>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y^// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(object: B {}) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.xs(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(A())
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(b) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(l : Array<Long>, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(-0.0) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun identity<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: A) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y °// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = foo()
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.C)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y≠// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    fun box(): String {
    val a = listOf(1u, 2u, 3u)
    var sum = 0
    a.forEachIndexed { index, uInt ->
        sum = sum * 10 + (index + 1) * uInt.toInt()
    }
    if (sum != 149) throw AssertionError()
    return "OK"
}
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(size.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y Û// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun box(): String {
    var flag = false
    do {
        if (flag) break
        continue
    } while (false)
    return "OK"
}
y©// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { {
    val result = B(11).result
    if (result != "1199") return "fail: $result"
    return "OK"
} }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class x(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { iterator() }
    }
    linearize(this@asLinearized)
}
y[// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.withSideEffect { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(Outer().test())
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yw// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { firstOrDefault({ it.reason == reason }, UNKNOWN) }
    }
    linearize(this@asLinearized)
}
y ®// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { }
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.it { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ¨// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = ArrayList<Int>()
y\// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Foo("ok").something().forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = add {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: property<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.baseProp.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: ZImpl<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: foo<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ¨// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { a++ }
yc// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {
        return u1 // box
    }
    }
    linearize(this@asLinearized)
}
yB// Original bug: KT-36100
//KT-2206

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

override class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y©// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {
        x -> when (x) {
            Season.SPRING -> "OK"
            else -> "fail"
        }
    }
    }
    linearize(this@asLinearized)
}
yC// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(public val name: String)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yF// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    fun bar(y: String): String {
        fun qux(z: String): String =
                x + y + z
        return qux("")
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { ArrayList(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        toLong()
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@String)
}
y Ø// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

inline fun <R> s1Obj(x: Obj, fn: (Int, Obj) -> R) = fn(1, x)
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    operator fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Any = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        next.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y6// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
    while (true) {
        try {
            continue;
        }
        finally {
            break;
        }
    }
    return "OK"
}
}
yD// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    listOf("OK")
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: String<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y Ï// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
        val next = C(c)
        c++
        return next
    }
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val e: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.data { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(i.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(217) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.foo(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun (UInt) -> ULong.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    inline fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class A(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, desc: KProperty<*>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun nonExhaustive(x: Int): Int {
    var r: Int = 4
    when (x) {
        1 -> r = 1
        2 -> r = 2
        3 -> r = 3
    }

    return r
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun s<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(0x00ff00)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.ys(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(a: String = "abc", val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): s<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Boolean.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y[// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun computeNext.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.C(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        x(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ¶// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = Derived(o)
y`// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(AssertionError) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    print(this@asLinearized)
}
yD// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    ByteArray(5)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: Int)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { this + it }
    }
    linearize(this@asLinearized)
}
yb// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        A<String?>(null).hashCode().forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(list.add("0"))
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Int(it) }
    }
    linearize(this@asLinearized)
}
y`// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(val callback: Callback) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun A<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yD// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(0)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.c { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): B<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y £// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = Local()
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(arg/2) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val box: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.invokeOnA.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(null, 0L)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yo// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { i, (x, y), v -> i.toString() + x + y + v }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// !LANGUAGE: +InlineClasses

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// TARGET_BACKEND: JVM

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: range1) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    A(this@asLinearized)
}
y ª// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { x ->
    screen[x]
}
yB// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Outer(null).test().fn
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: bad) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// KJS_WITH_FULL_RUNTIME

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y Ø// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {"$a:$b;"}
yA// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val arg: () -> String)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yZ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(23, {x -> 2 * x})
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y0// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
    if (x != null) throw AssertionError()
}
    linearize(this@asLinearized)
}
y †// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun less2(a: Double?, b: Double?) = a!! < b!!
y ∑// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun box(): String {
    val s = "v1: $v1, v2: $v2"
    return "OK"
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(Long: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y // Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        result += "2"
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.box)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// KJS_WITH_FULL_RUNTIME
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    doubleArrayOf(1.0)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        println(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.wrap2.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = bar {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y≠// Original bug: KT-36100
// Duplicated bug: KT-34754

inline class UInt(val value: Int) {
    operator fun plus(other: UInt) = UInt(value + other.value)
    fun otherValue(other: UInt) = other.value
}

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield()
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<K>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@A)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun Boolean.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun String<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.String(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { {
    true.hashCode()
    1.toByte().hashCode()
    1.toChar().hashCode()
    1.toShort().hashCode()
    1.hashCode()
    1L.hashCode()
    1.0F.hashCode()
    1.0.hashCode()
    "".hashCode()

    return "OK"
} }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: result<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(String: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        Int(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        b(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        a(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        String(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<ULong>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y=// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Foo()
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val a: Double, val b: Double)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y^// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun AssertionError.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Exception(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
    if (takeAny(AsInt(123)) != "asInt: 123") return "fail"
    if (takeAny(AsAny(321)) != "asAny: 321") return "fail"

    if (takeAny(AsInt(getInt())) != "asInt: 10") return "fail"
    if (takeAny(AsInt(id(20))) != "asInt: 20") return "fail"

    if (takeAny(AsAny(id(30))) != "asAny: 30") return "fail"

    return "OK"
}
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@run)
}
yó// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    fun box(): String {
    val s = StringBuilder()

    for ((_, x) in xs.withIndex()) {
        s.append("$x;")
    }

    val ss = s.toString()
    return if (ss == "a;b;c;d;") "OK" else "fail: '$ss'"
}
    linearize(this@asLinearized)
}
y// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
    var flag = false
    do {
        if (flag) break
        continue
    } while (false)
    return "OK"
}
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Any) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(A.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { add(i) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<bByte>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@range0)
}
ym// Original bug: KT-36100
// Duplicated bug: KT-34754

data class UnsupportedOperationException(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        Char.MIN_VALUE.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ´// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence { it }
yW// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(mapOf) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        A.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): TWO<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yD// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.toShort()
    }
    linearize(this@asLinearized)
}
y=// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, i)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yé// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {
        if (a > 0)
          return@run1 "OK"
        else "Fail 1"
    }
    }
    linearize(this@asLinearized)
}
y8// Original bug: KT-36100
// Duplicated bug: KT-34754

enum class State {
  O,
  K
}

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisl1@)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<A>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        A().getA().getA().forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(val x: UInt) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Double.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun sc<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yr// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { myAssertEquals(ni, Float.NEGATIVE_INFINITY) }
    }
    linearize(this@asLinearized)
}
yI// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@s)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Unit>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y «// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    {
    return t::toString
}
}
yF// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun UInt.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yf// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun InlineNotNullReference.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class a(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Any? = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yV// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(range1.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        list2.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yé// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize("wrong result as inner (actual): $actualAsInner ; expected: $resultAsInner")
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Inner) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize() }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.Z1 { linearize(it) }
    }
    linearize(this@asLinearized)
}
ya// Original bug: KT-36100
// Duplicated bug: KT-34754

private companion class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = A {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.n(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(delegate.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yU// Original bug: KT-36100
// Duplicated bug: KT-34754

inner class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yz// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    foo {
    val f = object {
        val a by del()
    }

    f.a
}
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { Boolean(it) }
    }
    linearize(this@asLinearized)
}
yX// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(String) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun this<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.toUShort.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.Test)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class UInt(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        setOf(1)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yB// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    Delegate()
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        tree.children.forEach { linearize(it) }
        yield(tree.value)
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754
fun Tree.asLinearized(): Sequence<Int> = sequence {
data class Tree(val value: Int, val children: List<Tree>)


    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yT// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
}
    linearize(this@asLinearized)
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree:Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized() Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        (tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yC// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach 
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

funTree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree..forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y •// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence 
y Œ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: ) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

 Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
     fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y9// Original bug: KT-36100


data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y<// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, )

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data classTree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearizetree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> =  {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(thisasLinearized)
}
yJ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: )

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yM// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children. { linearize(it) }
    }
    linearize(this@asLinearized)
}
yF// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> =sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y;// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): SequenceInt> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(treevalue)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val : Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y-// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        
    }
    linearize(this@asLinearized)
}
y8// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int,  children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence{
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach{ linearize(it) }
    }
    linearize(this@asLinearized)
}
yB// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun .linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    (this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: , val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        .children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: ListTree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

 class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence 
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearizethis@asLinearized)
}
y;
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

dataclass Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(valvalue: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.childrenforEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScopeInt>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend funSequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yH// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): <Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree){
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y// Original bug: KT-36100
// Duplicated bug: KT-34754



fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value:Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it)}
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun <Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        .forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) 
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }}
    linearize(this@asLinearized)
}
y*// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int>  sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Treeval value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ú// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = 
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        treechildren.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { (it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int,val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) 
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: <Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearizeit) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)

yK// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun TreeasLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yP// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun .asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, valchildren: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yN// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized():  = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized():Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yR// Original bug: KT-36100
// Duplicated bug: KT-34754data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yC// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(: Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children:List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yQ// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend  SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach  linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int>= sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
y ≠// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspendfun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yieldtree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yL// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val : List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yG// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {  }
    }
    linearize(this@asLinearized)
}
yO// Original bug: KT-36100
// Duplicated bug: KT-34754

data  Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized)
}
yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach {linearize(it) }
    }
    linearize(this@asLinearized)
}
xs// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)


yS// Original bug: KT-36100
// Duplicated bug: KT-34754

data class Tree(val value: Int, val children: List<Tree>)

fun Tree.asLinearized(): Sequence<Int> = sequence {
    suspend fun SequenceScope<Int>.linearize(tree: Tree) {
        yield(tree.value)
        tree.children.forEach { linearize(it) }
    }
    linearize(this@asLinearized
}
ˇˇ